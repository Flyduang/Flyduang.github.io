<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习小记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-03T02:48:31.625Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Flyduang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>160个CrackMe之004</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B004/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之004/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:48:31.625Z</updated>
    
    <content type="html"><![CDATA[<p>160个CrackMe，第4个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows  XP SP3</li><li>软件：CKme.exe</li><li>工具：PEiD v0.95、吾爱破解专用版OllyDbg、DeDeDark v3.50.04</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，需要用户名和注册码，验证成功则会显示“朱茵”小姐姐的照片。</p><p><img src="注册界面.png" alt="注册界面"></p><p>值得注意的是，该程序没有确定按钮，说明应该是每输入一次就读取输入框中的内容。而且，注册失败也不会出现失败提示，所以无法从失败提示入手。</p><p>首先PEiD进行查壳，无壳，Borland Delphi 编写。</p><p><img src="PEiD查壳.png" alt="PEiD查壳"></p><p>既然是Delphi编写，放入DeDe反编译看下，发现五个过程事件函数。</p><p><img src="DeDe反编译.png" alt="DeDe反编译"></p><p>根据事件函数的名称可以猜测分别是什么功能。首先应该分析下”chkcode”函数。</p><p>将程序载入OD，跳转到该函数地址。在函数开始下断，输入用户名和注册码，程序断下。</p><p>分析chkcode函数，主要分为两个部分。</p><ol><li>计算正确的注册码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00457C66  |.  8BB3 F8020000 mov esi,dword ptr ds:[ebx+0x2F8]         ;  获取用户名长度</span><br><span class="line">00457C6C  |.  83C6 05       add esi,0x5                              ;  长度加0x5</span><br><span class="line">00457C6F  |.  FFB3 10030000 push dword ptr ds:[ebx+0x310]            ;  压栈&quot;黑头Sun Bird&quot;</span><br><span class="line">00457C75  |.  8D55 F8       lea edx,[local.2]</span><br><span class="line">00457C78  |.  8BC6          mov eax,esi</span><br><span class="line">00457C7A  |.  E8 85FEFAFF   call CKme.00407B04                       ;  将数字转为Unicode字符串</span><br><span class="line">00457C7F  |.  FF75 F8       push [local.2]                           ;  压栈加0x5后的用户名长度</span><br><span class="line">00457C82  |.  FFB3 14030000 push dword ptr ds:[ebx+0x314]            ;  压栈&quot;dseloffc-012-OK&quot;</span><br><span class="line">00457C88  |.  8D55 F4       lea edx,[local.3]</span><br><span class="line">00457C8B  |.  8B83 D4020000 mov eax,dword ptr ds:[ebx+0x2D4]</span><br><span class="line">00457C91  |.  E8 B2B6FCFF   call CKme.00423348                       ;  获取用户名</span><br><span class="line">00457C96  |.  FF75 F4       push [local.3]                           ;  压栈用户名</span><br><span class="line">00457C99  |.  8D83 18030000 lea eax,dword ptr ds:[ebx+0x318]</span><br><span class="line">00457C9F  |.  BA 04000000   mov edx,0x4</span><br><span class="line">00457CA4  |.  E8 93BFFAFF   call CKme.00403C3C                       ;  拼接之前压栈的字符串</span><br></pre></td></tr></table></figure><ol start="2"><li>比较注册码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00457D1E  |.  8D55 E0       lea edx,[local.8]</span><br><span class="line">00457D21  |.  8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8]</span><br><span class="line">00457D27  |.  E8 1CB6FCFF   call CKme.00423348                       ;  获取输入的注册码</span><br><span class="line">00457D2C  |.  8B45 E0       mov eax,[local.8]</span><br><span class="line">00457D2F  |.  8B93 18030000 mov edx,dword ptr ds:[ebx+0x318]</span><br><span class="line">00457D35  |.  E8 52BFFAFF   call CKme.00403C8C                       ;  比较注册码</span><br><span class="line">00457D3A      75 0A         jnz short CKme.00457D46                  ;  跳转为失败，不跳转为成功</span><br><span class="line">00457D3C  |.  C783 0C030000&gt;mov dword ptr ds:[ebx+0x30C],0x3E ;设置注册标志</span><br><span class="line">00457D46  |&gt;  8B83 0C030000 mov eax,dword ptr ds:[ebx+0x30C]</span><br></pre></td></tr></table></figure><p>中间有一段用于混淆视听的代码，可以忽略。</p><p>该程序的注册码很简单：</p><ol><li>用户名长度 + 0x5，并转为Unicode字符串。</li><li>将“黑头Sun Bird”、“&lt;第一步字符串&gt;”、“dseloffc-012-OK”和用户名依次连接。</li></ol><p>如，用户名为“test”，则注册码为“黑头Sun Bird9dseloffc-012-OKtest”。</p><p>找到注册码之后，并不能直接显示“朱茵”小姐姐的照片。</p><p>在Panel1Click函数下断，可以看到注册成功的字符串。而想要显示注册成功，则注册标志必须为 0x85，但是在验证函数中，该标志被设置为 0x3E，那么一定有地方进行了修改。</p><p>在OD中搜索所有包含常量 0x85 的指令。</p><p><img src="搜索所有常量.png" alt="搜索所有常量"></p><p>找到修改代码，该代码位于 0x00457E7C 的函数中，而该函数是”Panel1DblClick”函数。</p><p>所以，在输入正确的用户名和注册码后，需要在图片框先双击，再单击，才最终注册成功。</p><p><img src="注册成功.png" alt="注册成功"></p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-613337-1-1.html" target="_blank" rel="noopener">[反汇编练习] 160个CrackMe之004（CKme）详细分析 (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个CrackMe，第4个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之002</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B002/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之002/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:43:34.989Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第二个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：Afkayas.1.exe</li><li>工具：PEiD v0.95、吾爱破解专用版OllyDbg</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，需要输入正确的用户名和密码。</p><p>PEiD查壳，无壳，Microsoft Visual Basic 编写。</p><p>输入任意用户名和注册码，得到失败提示。</p><p>载入OD，搜索字符串，确定错误提示位置。</p><p>逆向分析数据流，找到关键跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00402579   .  66:85F6       test si,si</span><br><span class="line">0040257C   .  8945 94       mov dword ptr ss:[ebp-0x6C],eax</span><br><span class="line">0040257F   .  894D AC       mov dword ptr ss:[ebp-0x54],ecx</span><br><span class="line">00402582   .  8945 A4       mov dword ptr ss:[ebp-0x5C],eax</span><br><span class="line">00402585   .  894D BC       mov dword ptr ss:[ebp-0x44],ecx</span><br><span class="line">00402588   .  8945 B4       mov dword ptr ss:[ebp-0x4C],eax</span><br><span class="line">0040258B   .  74 58         je short Afkayas_.004025E5               ;  跳转为注册失败，不跳转为注册成功</span><br></pre></td></tr></table></figure><p>得益于OD的强大，继续向上发现比较函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00402532   .  50            push eax</span><br><span class="line">00402533   .  FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;;  msvbvm50.__vbaStrCmp</span><br></pre></td></tr></table></figure><p>在此处下断，F9运行到这里，从栈中得到正确的验证码和输入的假码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012F408   0015E91C  UNICODE &quot;AKA-390240&quot;</span><br><span class="line">0012F40C   0015E8F4  UNICODE &quot;123456&quot;</span><br></pre></td></tr></table></figure><p>上方挨着字符串拼接函数，将“AKA-”与正确的序列号连接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00402510   &gt; \8B45 E8       mov eax,dword ptr ss:[ebp-0x18]</span><br><span class="line">00402513   .  8B4D E4       mov ecx,dword ptr ss:[ebp-0x1C]</span><br><span class="line">00402516   .  8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;;  msvbvm50.__vbaStrCat</span><br><span class="line">0040251C   .  50            push eax</span><br><span class="line">0040251D   .  68 701B4000   push Afkayas_.00401B70                   ;  AKA-</span><br><span class="line">00402522   .  51            push ecx                                 ; /String = &quot;3&quot;</span><br><span class="line">00402523   .  FFD7          call edi                                 ; \__vbaStrCat</span><br></pre></td></tr></table></figure><p>继续分析，找到序列号生成算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00402409   &gt; \8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]</span><br><span class="line">0040240F   .  8B45 E4       mov eax,dword ptr ss:[ebp-0x1C]</span><br><span class="line">00402412   .  50            push eax                                 ; /String = NULL</span><br><span class="line">00402413   .  8B1A          mov ebx,dword ptr ds:[edx]               ; |</span><br><span class="line">00402415   .  FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \__vbaLenBstr</span><br><span class="line">0040241B   .  8BF8          mov edi,eax</span><br><span class="line">0040241D   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]</span><br><span class="line">00402420   .  69FF FB7C0100 imul edi,edi,0x17CFB                     ;  用户名长度 * 0x17CFB</span><br><span class="line">00402426   .  51            push ecx                                 ; /String = &quot;?&quot;</span><br><span class="line">00402427   .  0F80 91020000 jo Afkayas_.004026BE                     ; |</span><br><span class="line">0040242D   .  FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr</span><br><span class="line">00402433   .  0FBFD0        movsx edx,ax</span><br><span class="line">00402436   .  03FA          add edi,edx                              ;  上一次乘法结果 + 用户名第一位的ASCII码</span><br><span class="line">00402438   .  0F80 80020000 jo Afkayas_.004026BE</span><br><span class="line">0040243E   .  57            push edi</span><br><span class="line">0040243F   .  FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;;  将十六进制转为十进制表示</span><br></pre></td></tr></table></figure><p>生成流程为：</p><ol><li>计算用户名长度。</li><li>长度与0x17CFB相乘。</li><li>第二步结果与用户名第一个字符的ASCII码相加。</li><li>将第三步结果转为十进制表示。</li><li>将十进制表示转为字符串类型。</li></ol><p>例如用户名为<strong>test</strong>，注册码为<strong>AKA-390240</strong>，输入程序，注册成功。</p><p>分析完毕！</p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-264394-1-1.html" target="_blank" rel="noopener">[反汇编练习] 160个CrackMe之002 (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第二个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之008</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B008/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之008/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:51:08.597Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第8个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：Andrénalin.1.exe</li><li>工具：PEiD v0.95、吾爱破解专用版OllyDbg</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，注册码注册。</p><p><img src="注册界面.png" alt="注册界面"></p><p>PEiD查壳，无壳，Microsoft Visual Basic 编写。</p><p><img src="PEiD查壳.png" alt="PEiD查壳"></p><p>输入任意注册码，弹出注册失败提示。</p><p><img src="注册失败.png" alt="注册失败"></p><p>载入OD，确定失败字符串的位置，定位注册函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00401D73   .  51            push ecx                                 ;  假码</span><br><span class="line">00401D74   .  68 541A4000   push Andréna.00401A54                    ;  SynTaX 2oo1</span><br><span class="line">00401D79   .  FF15 08314000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;;  msvbvm50.__vbaStrCmp</span><br><span class="line">00401D7F   .  8BF8          mov edi,eax</span><br><span class="line">00401D81   .  8D4D D8       lea ecx,dword ptr ss:[ebp-0x28]</span><br><span class="line">00401D84   .  F7DF          neg edi</span><br><span class="line">00401D86   .  1BFF          sbb edi,edi</span><br><span class="line">00401D88   .  47            inc edi</span><br><span class="line">00401D89   .  F7DF          neg edi</span><br><span class="line">00401D8B   .  FF15 5C314000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;;  msvbvm50.__vbaFreeStr</span><br><span class="line">00401D91   .  8D4D D4       lea ecx,dword ptr ss:[ebp-0x2C]</span><br><span class="line">00401D94   .  FF15 60314000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;;  msvbvm50.__vbaFreeObj</span><br><span class="line">00401D9A   .  66:3BFE       cmp di,si</span><br><span class="line">00401D9D   .  0F84 A0000000 je Andréna.00401E43                      ;  跳转为注册失败，不跳转为注册成功</span><br></pre></td></tr></table></figure><p>找到<code>__vbaStrCmp</code>字符串比较函数，下断后运行，可以在栈中看到比较的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012F3FC   00401A54  UNICODE &quot;SynTaX 2oo1&quot;</span><br><span class="line">0012F400   00161F1C  UNICODE &quot;123456&quot;</span><br></pre></td></tr></table></figure><p>输入的假码为“123456”，所以真码为“SynTaX 2oo1”。</p><p>进行验证。</p><p><img src="注册成功.png" alt="注册成功"></p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-613716-1-1.html" target="_blank" rel="noopener">初练160个CrakeMe程序之008 (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第8个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之010</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B010/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之010/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:53:29.160Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第10个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：Andrénalin.3</li><li>工具：PEiD v0.95、吾爱破解专用版OllyDbg</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，注册码验证。</p><p><img src="注册界面.png" alt="注册界面"></p><p>PEiD查壳，无壳，Microsoft Visual Basic 编写。</p><p><img src="PEiD查壳.png" alt="PEiD查壳"></p><p>输入任意注册码，提示注册失败。</p><p><img src="注册失败.png" alt="注册失败"></p><p>载入OD，确定失败字符串，定位关键跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00402050   .  66:85C0       test ax,ax</span><br><span class="line">00402053   .  0F84 C0000000 je Andréna.00402119                      ;  跳转为注册失败，不跳转为注册成功</span><br></pre></td></tr></table></figure><p>发现比较函数，加密后的真码为<code>kXy^rO|*yXo*m\kMuOn*+</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0040202B   &gt; \8D45 CC       lea eax,dword ptr ss:[ebp-0x34]</span><br><span class="line">0040202E   .  8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]</span><br><span class="line">00402034   .  50            push eax                                 ; /var18 = 0012F4AC</span><br><span class="line">00402035   .  51            push ecx                                 ; |var28 = 0012F434</span><br><span class="line">00402036   .  C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; |kXy^rO|*yXo*m\kMuOn*+</span><br><span class="line">00402040   .  C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x8008       ; |</span><br><span class="line">0040204A   .  FF15 40414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarTs&gt;; \__vbaVarTstEq</span><br></pre></td></tr></table></figure><p>向上分析，发现加密循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">00401F05   .  B9 02000000   mov ecx,0x2</span><br><span class="line">00401F0A   .  B8 01000000   mov eax,0x1</span><br><span class="line">00401F0F   .  898D 54FFFFFF mov dword ptr ss:[ebp-0xAC],ecx</span><br><span class="line">00401F15   .  898D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ecx</span><br><span class="line">00401F1B   .  8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]</span><br><span class="line">00401F21   .  8985 5CFFFFFF mov dword ptr ss:[ebp-0xA4],eax</span><br><span class="line">00401F27   .  8985 4CFFFFFF mov dword ptr ss:[ebp-0xB4],eax</span><br><span class="line">00401F2D   .  8D55 BC       lea edx,dword ptr ss:[ebp-0x44]</span><br><span class="line">00401F30   .  51            push ecx                                 ; /Step8 = 0012F434</span><br><span class="line">00401F31   .  8D45 94       lea eax,dword ptr ss:[ebp-0x6C]          ; |</span><br><span class="line">00401F34   .  52            push edx                                 ; |/var18 = 00000001</span><br><span class="line">00401F35   .  50            push eax                                 ; ||retBuffer8 = 0012F4AC</span><br><span class="line">00401F36   .  FF15 14414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenVa&gt;; |\__vbaLenVar</span><br><span class="line">00401F3C   .  8D8D 44FFFFFF lea ecx,dword ptr ss:[ebp-0xBC]          ; |</span><br><span class="line">00401F42   .  50            push eax                                 ; |End8 = 0012F4AC</span><br><span class="line">00401F43   .  8D95 ECFEFFFF lea edx,dword ptr ss:[ebp-0x114]         ; |</span><br><span class="line">00401F49   .  51            push ecx                                 ; |Start8 = 0012F434</span><br><span class="line">00401F4A   .  8D85 FCFEFFFF lea eax,dword ptr ss:[ebp-0x104]         ; |</span><br><span class="line">00401F50   .  52            push edx                                 ; |TMPend8 = 00000001</span><br><span class="line">00401F51   .  8D4D DC       lea ecx,dword ptr ss:[ebp-0x24]          ; |</span><br><span class="line">00401F54   .  50            push eax                                 ; |TMPstep8 = 0012F4AC</span><br><span class="line">00401F55   .  51            push ecx                                 ; |Counter8 = 0012F434</span><br><span class="line">00401F56   .  FF15 1C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForInit</span><br><span class="line">00401F5C   .  8B1D 68414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVa&gt;;  msvbvm50.__vbaVarCat</span><br><span class="line">00401F62   .  8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFr&gt;;  msvbvm50.__vbaFreeVarList</span><br><span class="line">00401F68   &gt;  85C0          test eax,eax</span><br><span class="line">00401F6A   .  0F84 BB000000 je Andréna.0040202B</span><br><span class="line">00401F70   .  8D55 94       lea edx,dword ptr ss:[ebp-0x6C]</span><br><span class="line">00401F73   .  8D45 DC       lea eax,dword ptr ss:[ebp-0x24]</span><br><span class="line">00401F76   .  52            push edx</span><br><span class="line">00401F77   .  50            push eax</span><br><span class="line">00401F78   .  C745 9C 01000&gt;mov dword ptr ss:[ebp-0x64],0x1</span><br><span class="line">00401F7F   .  C745 94 02000&gt;mov dword ptr ss:[ebp-0x6C],0x2</span><br><span class="line">00401F86   .  FF15 90414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaI4Var&gt;;  msvbvm50.__vbaI4Var</span><br><span class="line">00401F8C   .  8D4D BC       lea ecx,dword ptr ss:[ebp-0x44]          ; |</span><br><span class="line">00401F8F   .  50            push eax                                 ; |Start = 0x12F4AC</span><br><span class="line">00401F90   .  8D55 84       lea edx,dword ptr ss:[ebp-0x7C]          ; |</span><br><span class="line">00401F93   .  51            push ecx                                 ; |dString8 = 0012F434</span><br><span class="line">00401F94   .  52            push edx                                 ; |RetBUFFER = 00000001</span><br><span class="line">00401F95   .  FF15 34414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcMidCha&gt;; \rtcMidCharVar</span><br><span class="line">00401F9B   .  8D45 84       lea eax,dword ptr ss:[ebp-0x7C]</span><br><span class="line">00401F9E   .  8D4D A8       lea ecx,dword ptr ss:[ebp-0x58]</span><br><span class="line">00401FA1   .  50            push eax                                 ; /String8 = 0012F4AC</span><br><span class="line">00401FA2   .  51            push ecx                                 ; |ARG2 = 0012F434</span><br><span class="line">00401FA3   .  FF15 64414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrVa&gt;; \__vbaStrVarVal</span><br><span class="line">00401FA9   .  50            push eax                                 ; /String = &quot;&quot;</span><br><span class="line">00401FAA   .  FF15 08414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr</span><br><span class="line">00401FB0   .  66:05 0A00    add ax,0xA</span><br><span class="line">00401FB4   .  0F80 B0020000 jo Andréna.0040226A</span><br><span class="line">00401FBA   .  0FBFD0        movsx edx,ax</span><br><span class="line">00401FBD   .  52            push edx</span><br><span class="line">00401FBE   .  FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcBstrFr&gt;;  msvbvm50.rtcBstrFromAnsi</span><br><span class="line">00401FC4   .  8985 7CFFFFFF mov dword ptr ss:[ebp-0x84],eax</span><br><span class="line">00401FCA   .  8D45 CC       lea eax,dword ptr ss:[ebp-0x34]</span><br><span class="line">00401FCD   .  8D8D 74FFFFFF lea ecx,dword ptr ss:[ebp-0x8C]</span><br><span class="line">00401FD3   .  50            push eax</span><br><span class="line">00401FD4   .  8D95 64FFFFFF lea edx,dword ptr ss:[ebp-0x9C]</span><br><span class="line">00401FDA   .  51            push ecx</span><br><span class="line">00401FDB   .  52            push edx</span><br><span class="line">00401FDC   .  C785 74FFFFFF&gt;mov dword ptr ss:[ebp-0x8C],0x8</span><br><span class="line">00401FE6   .  FFD3          call ebx                                 ;  msvbvm50.__vbaVarCat</span><br><span class="line">00401FE8   .  8BD0          mov edx,eax</span><br><span class="line">00401FEA   .  8D4D CC       lea ecx,dword ptr ss:[ebp-0x34]</span><br><span class="line">00401FED   .  FFD6          call esi                                 ;  msvbvm50.__vbaVarMove</span><br><span class="line">00401FEF   .  8D4D A8       lea ecx,dword ptr ss:[ebp-0x58]</span><br><span class="line">00401FF2   .  FF15 B0414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;;  msvbvm50.__vbaFreeStr</span><br><span class="line">00401FF8   .  8D85 74FFFFFF lea eax,dword ptr ss:[ebp-0x8C]</span><br><span class="line">00401FFE   .  8D4D 84       lea ecx,dword ptr ss:[ebp-0x7C]</span><br><span class="line">00402001   .  50            push eax</span><br><span class="line">00402002   .  8D55 94       lea edx,dword ptr ss:[ebp-0x6C]</span><br><span class="line">00402005   .  51            push ecx</span><br><span class="line">00402006   .  52            push edx</span><br><span class="line">00402007   .  6A 03         push 0x3</span><br><span class="line">00402009   .  FFD7          call edi                                 ;  msvbvm50.__vbaFreeVarList</span><br><span class="line">0040200B   .  83C4 10       add esp,0x10</span><br><span class="line">0040200E   .  8D85 ECFEFFFF lea eax,dword ptr ss:[ebp-0x114]</span><br><span class="line">00402014   .  8D8D FCFEFFFF lea ecx,dword ptr ss:[ebp-0x104]</span><br><span class="line">0040201A   .  8D55 DC       lea edx,dword ptr ss:[ebp-0x24]</span><br><span class="line">0040201D   .  50            push eax                                 ; /TMPend8 = 0012F4AC</span><br><span class="line">0040201E   .  51            push ecx                                 ; |TMPstep8 = 0012F434</span><br><span class="line">0040201F   .  52            push edx                                 ; |Counter8 = 00000001</span><br><span class="line">00402020   .  FF15 A4414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForNext</span><br><span class="line">00402026   .^ E9 3DFFFFFF   jmp Andréna.00401F68</span><br></pre></td></tr></table></figure><p>实际很简单，就是将输入注册码的每一位加上 0xA，再与正确的加密验证码比较。</p><p>通过反向计算，可以得到真正的注册码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">char code[] = &quot;kXy^rO|*yXo*m\\kMuOn*+&quot;;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; strlen(code); i++)</span><br><span class="line">&#123;</span><br><span class="line">code[i] = code[i] - 0xA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：aNoThEr oNe cRaCkEd !。</p><p>进行验证。</p><p><img src="注册成功.png" alt="注册成功"></p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-266011-1-1.html" target="_blank" rel="noopener">[反汇编练习] 160个CrackMe之010 (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第10个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>植物大战僵尸之任意阳光修改</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/Game/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E4%BB%BB%E6%84%8F%E9%98%B3%E5%85%89%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/Game/植物大战僵尸之任意阳光修改/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:59:29.734Z</updated>
    
    <content type="html"><![CDATA[<p>植物大战僵尸是一款很经典的单机游戏了，作为很早之前的一款游戏，很适合作为学习分析游戏外挂的入门级练习。因此，在练习的同时，写下分析过程，作为学习的记录。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>系统：Windows 10 专业版 64位</li><li>软件：植物大战僵尸中文版</li><li><p>工具：CheatEngine v6.8.2</p></li><li><p>目标：任意阳光修改</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>游戏运行时所需要的数据，一般都会放在内存中，以便随时获取，特别时对于一些经常修改的数值。</p><p>植物大战僵尸中的阳关值就是经常变化的数值，所以，想要对其进行修改，首先要在内存中找到它的位置。</p><p>使用CE附加到游戏进程上，准备对其内存进行搜索。</p><p>查看当前游戏中阳光值。</p><p><img src="当前阳光值.png" alt="当前阳光值"></p><p>在CE中进行第一次搜索。</p><p><img src="CE第一次搜索结果.png" alt="CE第一次搜索结果"></p><p>搜索结果有773个，太多了。进入游戏改变阳光值，进行第二次搜索。</p><p><img src="CE第二次搜索结果.png" alt="CE第二次搜索结果"></p><p>结果剩了一个，那么这个就是要找的内存地址了。有时不会这么快出现唯一地址的，只需要多改变几次数值，进行搜索即可。</p><p>双击结果中的地址添加到下方的地址列表中，修改该地址数值，查看游戏中的阳光值，验证该地址。</p><p><img src="验证搜索结果.png" alt="验证搜索结果"></p><p>阳光值修改成功，证明该地址正确。</p><p>不过，这个内存地址只是临时的，是游戏中用来临时保存当前游戏局中阳光值的，重新开始关卡或者开始别的关卡，保存阳光值的地址就会发生变化。</p><p>但是，无论怎么变化，游戏总能准确的找到这个保存阳光的地址，那么游戏中一定存在一个基址，通过这个基地址，作为地址指针，经过一系列偏移，就可以确定每句游戏用来保存阳光值的地址了。</p><p>现在已经确定了当前游戏中保存阳光值的地址，那么通过查找有哪些地址访问了该地址，进而反向追溯，就可以找到阳光的基址了。</p><p>使用CE查找哪些地址访问了当前阳光保存地址。</p><p><img src="CE查找访问地址_5560.png" alt="CE查找访问地址"></p><p>可以看到有两个地址访问了当前阳光值地址，而这两个地址全都采用了 0x5560 的偏移量，所以寄存器的值就是上一级地址指针的中的值，为 0x1BC86BC8。</p><p>使用CE搜索哪些内存中保存着该指针。</p><p><img src="CE搜索第一级指针.png" alt="CE搜索第一级指针"></p><p>结果有很多，可以进行依次排除，不过，一般都是与其他结果相差比较大的就是我们要找的，这个是因为啥，我暂时没想明白。</p><p>这里就是结果中的第一个结果，加入地址列表。</p><p>查找访问哪些地址访问了该内存地址。</p><p><img src="CE查找访问地址_768.png" alt="CE查找访问地址"></p><p>可以明显看出，地址偏移为 0x768，寄存器中的值为 0x02809C80。</p><p>与上面一样，进行搜索。排除后有两个地址不确定，这两个地址都有一个固定地址访问，而且不同。</p><p><img src="CE搜索第二级指针结果.png" alt="CE搜索第二级指针结果"></p><p><img src="出现两个基地址.png" alt="出现两个基地址"></p><p>分别是 0x006A9EC0 和 0x006A9F38。</p><p>不过，既然是基地址，那么都有可能是阳光值的基址，添加指针地址，重新开始游戏，确定基址。</p><p><img src="设置两个指针地址.png" alt="设置两个指针地址"></p><p>最后证明，这两个都是游戏的基址，额！</p><p><img src="确定基址.png" alt="确定基址"></p><p>可能是因为游戏版本的问题吧，两个基址都可以使用。</p><p>最后整理分析出的数据。</p><p>阳光的基址为：0x006A9EC0 和 0x006A9F38。</p><p>偏移依次为：0x0、0x768 和 0x5560。</p><p>阳光地址计算为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二级指针 = [006A9EC0]</span><br><span class="line">第一级指针 = [第二级指针 + 0x768]</span><br><span class="line">阳光值地址 = [第一级指针 + 0x5560]</span><br></pre></td></tr></table></figure><p>依据这些地址与偏移，就可编写出任意修改阳光的程序了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;植物大战僵尸是一款很经典的单机游戏了，作为很早之前的一款游戏，很适合作为学习分析游戏外挂的入门级练习。因此，在练习的同时，写下分析过程，作为学习的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="游戏分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>植物大战僵尸之无限阳光</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/Game/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E6%97%A0%E9%99%90%E9%98%B3%E5%85%89/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/Game/植物大战僵尸之无限阳光/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T03:00:36.369Z</updated>
    
    <content type="html"><![CDATA[<p>植物大战僵尸系列分析记录，第二篇。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>系统：Windows 10 专业版 64位</li><li>软件：植物大战僵尸中文版</li><li>工具：CheatEngine v6.8.2</li><li>目标：无限阳光</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实现无限阳光的功能，只需要满足：</p><ul><li>阳光值设置为最大值9999。</li><li>阳光值不会减少。</li></ul><p>第一个条件在上一篇记录中已经实现，第二个条件需要确定阳光减少指令。</p><p>任意开始一局游戏，利用CE定位当前阳光值的地址。</p><p><img src="当前阳光值地址.png" alt="当前阳光值地址"></p><p>在该地址上右键选择“Find out what writes to this address”，确定哪些地址对该阳光值进行了修改。</p><p><img src="找出修改阳光值的指令.png" alt="找出修改阳光值的指令"></p><p>从指令上可以看出，第一条指令是增加阳光值的指令，第二条是修改阳光值的指令。</p><p>实现目标的方法有很多，我就任意选择了一种。</p><p>双击第二条指令，可以看到详细信息。</p><p><img src="修改阳光指令详细信息.png" alt="修改阳光值指令详细信息"></p><p>在 0x0041BA74 处是减法指令，可以猜测出esi中存储的是当前阳光值，而ebx存储的是需要减去的阳光值。</p><p>比较直接的方式就是将该指令nop掉，也可以将ebx改为 0x0，只要不减少阳光值即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;植物大战僵尸系列分析记录，第二篇。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="游戏分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>植物大战僵尸之无限种植</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/Game/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E6%97%A0%E9%99%90%E7%A7%8D%E6%A4%8D/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/Game/植物大战僵尸之无限种植/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T03:01:29.118Z</updated>
    
    <content type="html"><![CDATA[<p>植物大战僵尸分析练习，第三篇。</p><p>本次想要实现的功能是无限种植，即一块方格上可以无限种植植物。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>系统：Windows 10 x64 专业版</li><li>软件：植物大战僵尸中文版</li><li>工具：CheatEngine v6.8.2、吾爱破解专用版OllyDbg</li><li>目标：无限种植</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>整理思路，想要实现目标，需要寻找的有：</p><ol><li>植物种下代码。</li><li>该方块是否可以种植。</li></ol><p>以阳光值为切入点，定位当前阳光值地址。</p><p><img src="当前阳光值.png" alt="当前阳光值"></p><p>找出修改该处阳光值的指令。</p><p><img src="修改阳光值的指令.png" alt="修改阳光值的指令"></p><p>我选择第一条mov指令进行分析。</p><p>记录该指令地址，使用OD附加游戏进程（此时需要退出CE）。</p><p>跳转到该地址，该指令所在函数功能很简单，就是修改阳光值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0041BA60    56              push esi</span><br><span class="line">0041BA61    8BB7 60550000   mov esi,dword ptr ds:[edi+0x5560]</span><br><span class="line">0041BA67    8BD7            mov edx,edi</span><br><span class="line">0041BA69    E8 12FFFFFF     call Plants_v.0041B980</span><br><span class="line">0041BA6E    03C6            add eax,esi</span><br><span class="line">0041BA70    3BD8            cmp ebx,eax</span><br><span class="line">0041BA72    7F 0C           jg short Plants_v.0041BA80</span><br><span class="line">0041BA74    2BF3            sub esi,ebx                              ; 减去所需的阳光值</span><br><span class="line">0041BA76    89B7 60550000   mov dword ptr ds:[edi+0x5560],esi        ; 减少当前阳光值指令</span><br><span class="line">0041BA7C    B0 01           mov al,0x1</span><br><span class="line">0041BA7E    5E              pop esi</span><br><span class="line">0041BA7F    C3              retn</span><br></pre></td></tr></table></figure><p>下断，运行到上一层函数，对周围进行简单分析，可以猜测这里是植物种下代码逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0041083C    8B85 8C000000   mov eax,dword ptr ss:[ebp+0x8C]</span><br><span class="line">00410842    80B8 14080000 0&gt;cmp byte ptr ds:[eax+0x814],0x0</span><br><span class="line">00410849    75 33           jnz short Plants_v.0041087E</span><br><span class="line">0041084B    8BB5 38010000   mov esi,dword ptr ss:[ebp+0x138]         ; 猜测-esi的值为植物栏对象的地址</span><br><span class="line">00410851    837E 30 01      cmp dword ptr ds:[esi+0x30],0x1</span><br><span class="line">00410855    75 27           jnz short Plants_v.0041087E</span><br><span class="line">00410857    8BC5            mov eax,ebp</span><br><span class="line">00410859    E8 F2B50000     call Plants_v.0041BE50</span><br><span class="line">0041085E    84C0            test al,al</span><br><span class="line">00410860    75 1C           jnz short Plants_v.0041087E</span><br><span class="line">00410862    8B56 2C         mov edx,dword ptr ds:[esi+0x2C]</span><br><span class="line">00410865    8B46 28         mov eax,dword ptr ds:[esi+0x28]          ; 取得植物位置指令</span><br><span class="line">00410868    8BFD            mov edi,ebp</span><br><span class="line">0041086A    E8 71D20000     call Plants_v.0041DAE0                   ; 0x0041DAE0-获取当前需要减少的阳光值</span><br><span class="line">0041086F    8BD8            mov ebx,eax</span><br><span class="line">00410871    E8 EAB10000     call Plants_v.0041BA60                   ; 0x0041BA60-减少当前阳光值</span><br><span class="line">00410876    84C0            test al,al</span><br><span class="line">00410878    0F84 D4060000   je Plants_v.00410F52</span><br></pre></td></tr></table></figure><p>找到的第一个小目标，现在确定种植判断。</p><p>运行到函数返回，可以找到函数调用位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">004121FE    8B4D 0C         mov ecx,dword ptr ss:[ebp+0xC]</span><br><span class="line">00412201    8B55 08         mov edx,dword ptr ss:[ebp+0x8]</span><br><span class="line">00412204    51              push ecx</span><br><span class="line">00412205    52              push edx</span><br><span class="line">00412206    57              push edi</span><br><span class="line">00412207    8BCB            mov ecx,ebx</span><br><span class="line">00412209    E8 22DBFFFF     call Plants_v.0040FD30                   ; 0x0040FD30-种植植物函数</span><br><span class="line">0041220E    E8 0DC3FFFF     call Plants_v.0040E520</span><br></pre></td></tr></table></figure><p>从种植函数入口进行分析，寻找关键跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0040FE25    57              push edi</span><br><span class="line">0040FE26    53              push ebx</span><br><span class="line">0040FE27    55              push ebp</span><br><span class="line">0040FE28    E8 F3E1FFFF     call Plants_v.0040E020                   ; 判断该方块是否可以种植植物</span><br><span class="line">0040FE2D    85C0            test eax,eax</span><br><span class="line">0040FE2F    0F84 1F090000   je Plants_v.00410754                     ; 跳转为可种植</span><br></pre></td></tr></table></figure><p>这里就是游戏对方块是否可以种植进行判断的代码。</p><p>两个所需的位置已经确定，想要实现无限种植，只需要对跳转代码进行修改，或者进一步分析判断函数。</p><p>最后实现效果。</p><p><img src="最终实现效果.png" alt="最终实现效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;植物大战僵尸分析练习，第三篇。&lt;/p&gt;
&lt;p&gt;本次想要实现的功能是无限种植，即一块方格上可以无限种植植物。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="游戏分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>ESP脱壳法</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/Software/ESP%E8%84%B1%E5%A3%B3%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/Software/ESP脱壳法/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:57:42.804Z</updated>
    
    <content type="html"><![CDATA[<p>ESP脱壳方法是一种常用的快速手动脱壳的方法，针对一些常见的传统PE外壳很有效，但是并不适用所有的外壳。</p><p>演示使用UPX加壳notepad.exe。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>外壳：<a href="https://upx.github.io/" target="_blank" rel="noopener">UPX v3.95</a></li><li>软件：notepad.exe</li><li>工具：PEiD v0.95、ExeinfoPE v0.0.5.1、吾爱破解专用版OllyDbg、ImportREConstructor v1.7e</li></ul><h2 id="0x2-操作"><a href="#0x2-操作" class="headerlink" title="0x2 操作"></a>0x2 操作</h2><p><strong>1、加壳</strong></p><p>使用UPX对notepad.exe进行加壳。</p><p><img src="UPX加壳.png" alt="UPX加壳"></p><p><strong>2、查壳</strong></p><p>使用PEiD查壳，因为PEiD长久未更新，所以无法识别。</p><p><img src="PEiD查壳.png" alt="PEiD查壳"></p><p>使用ExeinfoPE查壳，识别正确。</p><p><img src="ExeinfoPE查壳.png" alt="ExeinfoPE查壳"></p><p>当使用一款查壳工具没有结果时，多试几种看看，说不定就有意外收获。</p><p><strong>3、脱壳</strong></p><p>载入OD，可能会提示代码被压缩，无视，继续分析。</p><p>加载成功后，即可看到外壳入口。</p><p><img src="upx外壳入口.png" alt="upx外壳入口"></p><p>单步执行pushad指令，然后右键ESP寄存器，选择“数据窗口中跟随”，可以看到数据窗口中被压入内存中的各寄存器的值。</p><p><img src="被压入内存中的寄存器的值.png" alt="被压入内存的寄存器的值"></p><p>在第一个十六进制值上右键，下DWORD类型的硬件访问断点。</p><p><img src="设置硬件访问断点.png" alt="设置硬件访问断点"></p><p>F9运行程序，OD将会中断在popad指令后。运行到一个大跳转过后，即可到达程序的OEP。</p><p><img src="外壳结尾的跳转.png" alt="OEP跳转"></p><p>在程序OEP右键，选择“用OllyDump脱壳调试进程”。设置好入口地址，其他默认，点击脱壳完成Dump程序。</p><p><img src="OllyDump设置.png" alt="OllyDump设置"></p><p>此时不能关闭OD，因为刚脱壳后的程序还未修复，所以无法运行，而修复程序则需要读取内存中的原IAT等地址。所以OD调试的进程不能关闭。</p><p><strong>4、修复</strong></p><p>打开ImportREConstructor，附加到脱壳进程。</p><p><img src="ImportREC设置.png" alt="Import附加进程"></p><p>在OEP输入框中输入OEP的地址，点击“IAT自动搜索”，程序将会自动搜索内存中的IAT地址。</p><p>发现原始IAT后，点击“获取导入表”，得到内存中导入表。</p><p>点击“修正转储”，选择刚刚脱壳的程序文件，进行修复。</p><p>等程序日志中提示保存成功后，便完成了修复。</p><p><img src="ImportREC完成修复.png" alt="ImportREC完成修复"></p><p>此时程序已经脱壳，且可以正常运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ESP脱壳方法是一种常用的快速手动脱壳的方法，针对一些常见的传统PE外壳很有效，但是并不适用所有的外壳。&lt;/p&gt;
&lt;p&gt;演示使用UPX加壳notepad.exe。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="软件分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>植物大战僵尸之植物无CD</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/Game/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E6%A4%8D%E7%89%A9%E6%97%A0CD/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/Game/植物大战僵尸之植物无CD/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T03:02:23.078Z</updated>
    
    <content type="html"><![CDATA[<p>继续分析植物大战僵尸，第四篇，这次的目标是植物无CD效果。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>系统：Windows 10 x64 专业版</li><li>软件：植物大战僵尸中文版</li><li>工具：CheatEngine v6.8.2、吾爱破解专用版OllyDbg</li><li>目标：植物无CD</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>整理思路。</p><p>在游戏中多次实验可以发现，当点击植物卡片时，会触发两种情况，一种是装填完毕，一种是未装填完毕。</p><p>猜测游戏中对植物装填状态有一个判断，而且是发生在点击植物卡片之后，所以，目标可以分为两个部分：</p><ul><li>寻找植物卡片点击事件处理</li><li>寻找植物装填状态判断</li></ul><p>进行分析。</p><p><strong>1. 寻找植物卡片点击事件</strong></p><p>第一个目标，可以将第三篇的植物种植函数来作为切入点。</p><p>搜索当前阳光存储地址，找出减少阳光值指令。</p><p>单步执行出种植函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">004121FE  |.  8B4D 0C       mov ecx,[arg.2]                          ;  kernel32.772887DD</span><br><span class="line">00412201  |.  8B55 08       mov edx,[arg.1]</span><br><span class="line">00412204  |.  51            push ecx</span><br><span class="line">00412205  |.  52            push edx</span><br><span class="line">00412206  |.  57            push edi</span><br><span class="line">00412207  |.  8BCB          mov ecx,ebx</span><br><span class="line">00412209  |.  E8 22DBFFFF   call Plants_v.0040FD30                   ;  0x0040FD30-种植植物函数</span><br><span class="line">0041220E  |.  E8 0DC3FFFF   call Plants_v.0040E520</span><br><span class="line">00412213  |.  5F            pop edi                                  ;  0019FD00</span><br><span class="line">00412214  |.  5E            pop esi                                  ;  0019FD00</span><br><span class="line">00412215  |.  5B            pop ebx                                  ;  0019FD00</span><br><span class="line">00412216  |.  8BE5          mov esp,ebp</span><br><span class="line">00412218  |.  5D            pop ebp                                  ;  0019FD00</span><br><span class="line">00412219  |.  C2 0C00       retn 0xC</span><br></pre></td></tr></table></figure><p>向上找到函数头部，下断，就可以发现该函数就是植物卡片点击事件处理函数。</p><p><strong>2. 寻找植物装填状态判断</strong></p><p>点击植物分为可种植和不可种植两种状态，所以从种植函数开始逆向分析点击事件处理函数。</p><p>种植函数上方就是一个判断跳转，简单分析可以猜测其功能是判断本次点击是否为放下植物。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004121F3  |.  8BC7          mov eax,edi</span><br><span class="line">004121F5  |.  E8 E6AAFFFF   call Plants_v.0040CCE0                   ;  猜测-判断本次鼠标点击是否为放下植物</span><br><span class="line">004121FA  |.  84C0          test al,al</span><br><span class="line">004121FC  |.  74 1E         je short Plants_v.0041221C</span><br></pre></td></tr></table></figure><p>而且可以发现，无论植物是否装填完毕，都会运行到该函数位置。</p><p>对该函数的参数与返回结果进行比较分析。</p><p>确定无论是否装填完毕，同一植物情况下参数与返回结果都相同。</p><p>所以装填状态判断还在后面，继续单步分析。</p><p>跳转后出现两个函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0041221C  |&gt; \83FA 04       cmp edx,0x4                              ;  Switch (cases 1..F)</span><br><span class="line">0041221F  |.  75 28         jnz short Plants_v.00412249</span><br><span class="line">00412221  |.  8B4424 10     mov eax,dword ptr ss:[esp+0x10]          ;  Case 4 of switch 0041221C</span><br><span class="line">00412225  |.  8B48 04       mov ecx,dword ptr ds:[eax+0x4]</span><br><span class="line">00412228  |.  80B9 64010000&gt;cmp byte ptr ds:[ecx+0x164],0x0</span><br><span class="line">0041222F  |.  0F85 EB000000 jnz Plants_v.00412320</span><br><span class="line">00412235  |.  50            push eax</span><br><span class="line">00412236  |.  E8 55630700   call Plants_v.00488590                   ;  冷却判断函数</span><br><span class="line">0041223B  |.  E8 E0C2FFFF   call Plants_v.0040E520</span><br><span class="line">00412240  |.  5F            pop edi                                  ;  0019FD00</span><br><span class="line">00412241  |.  5E            pop esi                                  ;  0019FD00</span><br><span class="line">00412242  |.  5B            pop ebx                                  ;  0019FD00</span><br><span class="line">00412243  |.  8BE5          mov esp,ebp</span><br><span class="line">00412245  |.  5D            pop ebp                                  ;  0019FD00</span><br><span class="line">00412246  |.  C2 0C00       retn 0xC</span><br></pre></td></tr></table></figure><p>同样对齐进行参数比较后，发现 0x00488590 函数的参数与返回结果出现了变化。</p><p>以向日葵为对象（左为装填完毕，右为装填中）。</p><p>参数比较：</p><p><img src="函数参数比较.png" alt="函数参数比较"></p><p>返回结果比较：</p><p><img src="函数返回结果比较.png" alt="函数返回结果比较"></p><p>修改执行后的eax返回值，发现在装填状态下可以种植植物，确定该函数就是装填状态判断函数。</p><p>F7进入分析，确定关键跳转位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00488684  |.  807D 48 00    cmp byte ptr ss:[ebp+0x48],0x0           ;  冷却判断</span><br><span class="line">00488688  |.  0F85 79010000 jnz Plants_v.00488807                    ;  成功跳转</span><br></pre></td></tr></table></figure><p>猜测 [ebp+0x48] 指向的内存地址为装填状态标志，0x00为装填中，0x01为装填完毕。</p><p>在标志上下内存写入断点，运行游戏，确定标志设置指令。</p><p>设置为装填中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00488E71  |&gt; \33C0          xor eax,eax                              ;  Default case of switch 00488E3B</span><br><span class="line">00488E73  |.  C645 48 00    mov byte ptr ss:[ebp+0x48],0x0           ;  修改装填标志为装填中</span><br><span class="line">00488E77  |.  8945 24       mov [arg.8],eax</span><br><span class="line">00488E7A  |.  8945 28       mov [arg.9],eax</span><br></pre></td></tr></table></figure><p>设置为装填完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00487298  |.  C747 24 00000&gt;mov dword ptr ds:[edi+0x24],0x0</span><br><span class="line">0048729F  |.  C647 49 00    mov byte ptr ds:[edi+0x49],0x0</span><br><span class="line">004872A3  |.  C647 48 01    mov byte ptr ds:[edi+0x48],0x1           ;  设置装填标志为装填完毕</span><br><span class="line">004872A7  |.  E8 E4FEFFFF   call Plants_v.00487190</span><br><span class="line">004872AC  |&gt;  8B47 3C       mov eax,dword ptr ds:[edi+0x3C]</span><br></pre></td></tr></table></figure><p>分析完毕，只需要将设置为装填中的指令，修改为设置为装填完毕，即可实现植物无CD的目标。</p><p>效果如图：</p><p><img src="实现效果.png" alt="实现效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续分析植物大战僵尸，第四篇，这次的目标是植物无CD效果。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="游戏分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>WinRAR去广告窗口</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/Software/WinRAR%E5%8E%BB%E5%B9%BF%E5%91%8A%E7%AA%97%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/Software/WinRAR去广告窗口/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:55:01.380Z</updated>
    
    <content type="html"><![CDATA[<p>WinRAR虽然推出了免费的中文个人版，但是新添加的广告窗口让人烦不胜烦。尽管理解其这种商业行为，不过对于个人来说，还是抗拒这种事情的。</p><p>之前曾经尝试过去除广告窗口，但是最后限于水平（现在也不咋地）而失败了。这次换了一种思路，发现还是很简单就可以去除的。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>系统：Windows 7 SP1 x64 ultimate</li><li>工具：吾爱破解专用版OllyDbg、x64dbg</li><li>软件：WinRAR 中文个人版 v5.6.1 32/64位</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>32位和64位的修改思路是一样的，但是作为记录的话，还是都写一下比较好。</p><p>大致思路如下：</p><p>根据WinRAR窗口出现的时间可以猜测，广告窗口是在主窗口之后被创建或者被设置为显示的，所以从窗口函数切入，确定其出现时所调用的窗口函数，然后进行分析。</p><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>在所有CreateWindowExW函数上下断点，根据堆栈中的函数参数来判断广告窗口的创建位置。</p><p><img src="堆栈中的函数参数.png" alt="堆栈中的函数参数"></p><p>最后确定广告窗口出现时的CreateWindowExW为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">012F07A0  |.  53            push ebx                                 ; /lParam = 006D14E0</span><br><span class="line">012F07A1  |.  FF33          push dword ptr ds:[ebx]                  ; |hInst = 01230000</span><br><span class="line">012F07A3  |.  6A 00         push 0x0                                 ; |hMenu = NULL</span><br><span class="line">012F07A5  |.  55            push ebp                                 ; |/hWnd = 000302A2 (class=&apos;Static&apos;,parent=000402A6)</span><br><span class="line">012F07A6  |.  FF15 20663401 call dword ptr ds:[&lt;&amp;USER32.GetParent&gt;]  ; |\GetParent</span><br><span class="line">012F07AC  |.  8B4C24 20     mov ecx,dword ptr ss:[esp+0x20]          ; |apisetsc.000402A6</span><br><span class="line">012F07B0  |.  50            push eax                                 ; |hParent = 000002D4</span><br><span class="line">012F07B1  |.  8B4424 2C     mov eax,dword ptr ss:[esp+0x2C]          ; |</span><br><span class="line">012F07B5  |.  2BC1          sub eax,ecx                              ; |</span><br><span class="line">012F07B7  |.  50            push eax                                 ; |Height = 2D4 (724.)</span><br><span class="line">012F07B8  |.  56            push esi                                 ; |Width = 39C (924.)</span><br><span class="line">012F07B9  |.  51            push ecx                                 ; |Y = 0x0</span><br><span class="line">012F07BA  |.  57            push edi                                 ; |X = 0x0</span><br><span class="line">012F07BB  |.  68 00000040   push 0x40000000                          ; |Style = WS_CHILD</span><br><span class="line">012F07C0  |.  6A 00         push 0x0                                 ; |WindowName = NULL</span><br><span class="line">012F07C2  |.  68 C8D03401   push WinRAR.0134D0C8                     ; |Class = &quot;RarHtmlClassName&quot;</span><br><span class="line">012F07C7  |.  6A 00         push 0x0                                 ; |ExtStyle = 0</span><br><span class="line">012F07C9  |.  FF15 9C653401 call dword ptr ds:[&lt;&amp;USER32.CreateWindow&gt;; \CreateWindowExW</span><br></pre></td></tr></table></figure><p>其参数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0038A584   00000000  |ExtStyle = 0</span><br><span class="line">0038A588   0134D0C8  |Class = &quot;RarHtmlClassName&quot;</span><br><span class="line">0038A58C   00000000  |WindowName = NULL</span><br><span class="line">0038A590   40000000  |Style = WS_CHILD</span><br><span class="line">0038A594   00000000  |X = 0x0</span><br><span class="line">0038A598   00000000  |Y = 0x0</span><br><span class="line">0038A59C   0000039C  |Width = 39C (924.)</span><br><span class="line">0038A5A0   000002D4  |Height = 2D4 (724.)</span><br><span class="line">0038A5A4   00390230  |hParent = 00390230 (&apos;WinRAR&apos;,class=&apos;RarReminder&apos;)</span><br><span class="line">0038A5A8   00000000  |hMenu = NULL</span><br><span class="line">0038A5AC   01230000  |hInst = 01230000</span><br><span class="line">0038A5B0   004E1BD8  \lParam = 004E1BD8</span><br></pre></td></tr></table></figure><p>可以猜测这里是创建用于显示广告内容的窗口。</p><p>hParent参数显示了其父窗口的类型和窗口名，确定其父窗口创建位置。</p><p><img src="32位广告窗口创建位置.png" alt="广告窗口创建位置"></p><p>窗口名为“WinRAR”，且前面紧挨着广告链接“<a href="https://ad.winrar.com.cn/show_2.html?L=7&amp;bl=7&amp;v=561personal&amp;a=32&amp;src=cn”。" target="_blank" rel="noopener">https://ad.winrar.com.cn/show_2.html?L=7&amp;bl=7&amp;v=561personal&amp;a=32&amp;src=cn”。</a></p><p>可以推测这里就是广告窗口的创建位置。</p><p>去除的方式有很多，这里选择修改其Style参数为0。</p><p>修改位置有两处。</p><p>第一处为：</p><p><code>000C6F53  |.  81CF 0000C816 or edi,0x16C80000</code></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000C6F53      83CF 00       or edi,0x0</span><br><span class="line">000C6F56      90            nop</span><br><span class="line">000C6F57      90            nop</span><br><span class="line">000C6F58      90            nop</span><br></pre></td></tr></table></figure><p>第二处为：</p><p><code>000C6F62  |.  81CF 00000300 or edi,0x30000</code></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000C6F62      83CF 00       or edi,0x0</span><br><span class="line">000C6F65      90            nop</span><br><span class="line">000C6F66      90            nop</span><br><span class="line">000C6F67      90            nop</span><br></pre></td></tr></table></figure><p>保存文件即可实现去除广告窗口的效果。</p><h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>64位的思路一样，操作步骤也差不多。</p><p>其窗口创建位置为：</p><p><img src="64位广告窗口创建位置.png" alt="广告窗口创建位置"></p><p>第一处修改为：</p><p><code>000000013F0D15C1 | 81C9 0000C816            | or ecx,16C80000                         |</code></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000000013F0D15C1 | 83C9 00                  | or ecx,0                                |</span><br><span class="line">000000013F0D15C4 | 90                       | nop                                     |</span><br><span class="line">000000013F0D15C5 | 90                       | nop                                     |</span><br><span class="line">000000013F0D15C6 | 90                       | nop                                     |</span><br></pre></td></tr></table></figure><p>第二处修改为：</p><p><code>000000013F0D15C9 | 81CE 00000300            | or esi,30000                            | 30000:&quot;Actx &quot;</code></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000000013F0D15C9 | 83CE 00                  | or esi,0                                |</span><br><span class="line">000000013F0D15CC | 90                       | nop                                     |</span><br><span class="line">000000013F0D15CD | 90                       | nop                                     |</span><br><span class="line">000000013F0D15CE | 90                       | nop                                     |</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WinRAR虽然推出了免费的中文个人版，但是新添加的广告窗口让人烦不胜烦。尽管理解其这种商业行为，不过对于个人来说，还是抗拒这种事情的。&lt;/p&gt;
&lt;p&gt;之前曾经尝试过去除广告窗口，但是最后限于水平（现在也不咋地）而失败了。这次换了一种思路，发现还是很简单就可以去除的。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="软件分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之001</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B001/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之001/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:39:01.860Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第1个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：Acid_burn.exe</li><li>工具：PEiD v0.95、吾爱破解专用版OllyDbg</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，有三处需要分析的位置。一处初始弹窗，一处注册码注册，还有一处用户名与注册码注册。</p><p>先进行查壳，无壳，Borland Delphi 3.0 编写。</p><p>首先去除初始弹窗。</p><p>将程序拖入OD，搜素弹窗内容字符串，定位弹窗函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0042F784   .  6A 00         push 0x0</span><br><span class="line">0042F786   .  B9 A0F74200   mov ecx,Acid_bur.0042F7A0                ;  hello you have to kill me!</span><br><span class="line">0042F78B   .  BA BCF74200   mov edx,Acid_bur.0042F7BC                ;  Welcome to this Newbies Crackme made by ACiD BuRN [CracKerWoRlD]</span><br><span class="line">0042F790   .  A1 480A4300   mov eax,dword ptr ds:[0x430A48]</span><br><span class="line">0042F795   .  8B00          mov eax,dword ptr ds:[eax]</span><br><span class="line">0042F797   .  E8 D4A9FFFF   call Acid_bur.0042A170                   ;  弹窗函数</span><br></pre></td></tr></table></figure><p>将 0x0042F784 处的<code>push 0x0</code>修改为<code>retn</code>，即可去除弹窗。</p><p>然后分析只需要注册码的注册窗口。</p><p>输入假码，获得失败提示。</p><p>OD中搜索字符串，确定该错误提示，定位注册函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0042F48A  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">0042F48D  |.  BA 40F54200   mov edx,Acid_bur.0042F540                ;  Hello</span><br><span class="line">0042F492  |.  E8 7142FDFF   call Acid_bur.00403708</span><br><span class="line">0042F497  |.  8D45 F8       lea eax,[local.2]</span><br><span class="line">0042F49A  |.  BA 50F54200   mov edx,Acid_bur.0042F550                ;  Dude!</span><br><span class="line">0042F49F  |.  E8 6442FDFF   call Acid_bur.00403708</span><br><span class="line">0042F4A4  |.  FF75 FC       push [local.1]                           ;  Acid_bur.0042F540</span><br><span class="line">0042F4A7  |.  68 60F54200   push Acid_bur.0042F560</span><br><span class="line">0042F4AC  |.  FF75 F8       push [local.2]                           ;  Acid_bur.0042F550</span><br><span class="line">0042F4AF  |.  8D45 F4       lea eax,[local.3]</span><br><span class="line">0042F4B2  |.  BA 03000000   mov edx,0x3</span><br><span class="line">0042F4B7  |.  E8 F044FDFF   call Acid_bur.004039AC                   ;  获得正确注册码</span><br><span class="line">0042F4BC  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">0042F4BF  |.  8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]</span><br><span class="line">0042F4C5  |.  E8 8EB5FEFF   call Acid_bur.0041AA58                   ;  获取输入注册码</span><br><span class="line">0042F4CA  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042F4CD  |.  8B55 F4       mov edx,[local.3]</span><br><span class="line">0042F4D0  |.  E8 2745FDFF   call Acid_bur.004039FC                   ;  验证函数</span><br><span class="line">0042F4D5  |.  75 1A         jnz short Acid_bur.0042F4F1              ;  跳转为注册失败，不跳转为注册成功</span><br></pre></td></tr></table></figure><p> 0x0042F4D0 处函数的参数为正确注册码与输入注册码，在该处下断，得到正确的注册码为<strong>Hello Dude!</strong>。</p><p>最后分析需要用户名和注册码共同注册的窗口。</p><p>输入任意用户名与假码，获得错误提示。</p><p>OD中搜索该字符串，确定字符串位置，定位注册函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">0042F9BF  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">0042F9C2  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]</span><br><span class="line">0042F9C8  |.  E8 8BB0FEFF   call Acid_bur.0041AA58                   ;  获取用户名</span><br><span class="line">0042F9CD  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042F9D0  |.  E8 DB40FDFF   call Acid_bur.00403AB0</span><br><span class="line">0042F9D5  |.  A3 6C174300   mov dword ptr ds:[0x43176C],eax          ;  Acid_bur.0042FAEA</span><br><span class="line">0042F9DA  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">0042F9DD  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]</span><br><span class="line">0042F9E3  |.  E8 70B0FEFF   call Acid_bur.0041AA58</span><br><span class="line">0042F9E8  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042F9EB  |.  0FB600        movzx eax,byte ptr ds:[eax]              ;  获取用户名第一个字符</span><br><span class="line">0042F9EE  |.  8BF0          mov esi,eax                              ;  Acid_bur.0042FAEA</span><br><span class="line">0042F9F0  |.  C1E6 03       shl esi,0x3                              ;  逻辑左移3位</span><br><span class="line">0042F9F3  |.  2BF0          sub esi,eax                              ;  左移后的结果减去原字符</span><br><span class="line">0042F9F5  |.  8D55 EC       lea edx,[local.5]</span><br><span class="line">0042F9F8  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]</span><br><span class="line">0042F9FE  |.  E8 55B0FEFF   call Acid_bur.0041AA58</span><br><span class="line">0042FA03  |.  8B45 EC       mov eax,[local.5]</span><br><span class="line">0042FA06  |.  0FB640 01     movzx eax,byte ptr ds:[eax+0x1]          ;  获取用户名第二个字符</span><br><span class="line">0042FA0A  |.  C1E0 04       shl eax,0x4                              ;  逻辑左移4位</span><br><span class="line">0042FA0D  |.  03F0          add esi,eax                              ;  加上上一次的结果</span><br><span class="line">0042FA0F  |.  8935 54174300 mov dword ptr ds:[0x431754],esi</span><br><span class="line">0042FA15  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">0042FA18  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]</span><br><span class="line">0042FA1E  |.  E8 35B0FEFF   call Acid_bur.0041AA58</span><br><span class="line">0042FA23  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042FA26  |.  0FB640 03     movzx eax,byte ptr ds:[eax+0x3]          ;  获取用户名第4个字符</span><br><span class="line">0042FA2A  |.  6BF0 0B       imul esi,eax,0xB                         ;  与0xB相乘</span><br><span class="line">0042FA2D  |.  8D55 EC       lea edx,[local.5]</span><br><span class="line">0042FA30  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]</span><br><span class="line">0042FA36  |.  E8 1DB0FEFF   call Acid_bur.0041AA58</span><br><span class="line">0042FA3B  |.  8B45 EC       mov eax,[local.5]</span><br><span class="line">0042FA3E  |.  0FB640 02     movzx eax,byte ptr ds:[eax+0x2]          ;  获取用户名第3个字符</span><br><span class="line">0042FA42  |.  6BC0 0E       imul eax,eax,0xE                         ;  与0xE相乘</span><br><span class="line">0042FA45  |.  03F0          add esi,eax                              ;  与上一次结果相加</span><br><span class="line">0042FA47  |.  8935 58174300 mov dword ptr ds:[0x431758],esi</span><br><span class="line">0042FA4D  |.  A1 6C174300   mov eax,dword ptr ds:[0x43176C]</span><br><span class="line">0042FA52  |.  E8 D96EFDFF   call Acid_bur.00406930</span><br><span class="line">0042FA57  |.  83F8 04       cmp eax,0x4</span><br><span class="line">0042FA5A  |.  7D 1D         jge short Acid_bur.0042FA79              ;  用户名长度需要大于等于4</span><br><span class="line">0042FA5C  |.  6A 00         push 0x0</span><br><span class="line">0042FA5E  |.  B9 74FB4200   mov ecx,Acid_bur.0042FB74                ;  Try Again!</span><br><span class="line">0042FA63  |.  BA 80FB4200   mov edx,Acid_bur.0042FB80                ;  Sorry , The serial is incorect !</span><br><span class="line">0042FA68  |.  A1 480A4300   mov eax,dword ptr ds:[0x430A48]</span><br><span class="line">0042FA6D  |.  8B00          mov eax,dword ptr ds:[eax]</span><br><span class="line">0042FA6F  |.  E8 FCA6FFFF   call Acid_bur.0042A170</span><br><span class="line">0042FA74  |.  E9 BE000000   jmp Acid_bur.0042FB37</span><br><span class="line">0042FA79  |&gt;  8D55 F0       lea edx,[local.4]</span><br><span class="line">0042FA7C  |.  8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]</span><br><span class="line">0042FA82  |.  E8 D1AFFEFF   call Acid_bur.0041AA58</span><br><span class="line">0042FA87  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">0042FA8A  |.  0FB600        movzx eax,byte ptr ds:[eax]              ;  取出用户名第一个字符</span><br><span class="line">0042FA8D  |.  F72D 50174300 imul dword ptr ds:[0x431750]             ;  与0x29相乘</span><br><span class="line">0042FA93  |.  A3 50174300   mov dword ptr ds:[0x431750],eax          ;  Acid_bur.0042FAEA</span><br><span class="line">0042FA98  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]</span><br><span class="line">0042FA9D  |.  0105 50174300 add dword ptr ds:[0x431750],eax          ;  结果与结果相加</span><br><span class="line">0042FAA3  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">0042FAA6  |.  BA ACFB4200   mov edx,Acid_bur.0042FBAC                ;  CW</span><br><span class="line">0042FAAB  |.  E8 583CFDFF   call Acid_bur.00403708</span><br><span class="line">0042FAB0  |.  8D45 F8       lea eax,[local.2]</span><br><span class="line">0042FAB3  |.  BA B8FB4200   mov edx,Acid_bur.0042FBB8                ;  CRACKED</span><br><span class="line">0042FAB8  |.  E8 4B3CFDFF   call Acid_bur.00403708</span><br><span class="line">0042FABD  |.  FF75 FC       push [local.1]                           ;  Acid_bur.0042FBAC</span><br><span class="line">0042FAC0  |.  68 C8FB4200   push Acid_bur.0042FBC8                   ;  -</span><br><span class="line">0042FAC5  |.  8D55 E8       lea edx,[local.6]</span><br><span class="line">0042FAC8  |.  A1 50174300   mov eax,dword ptr ds:[0x431750]</span><br><span class="line">0042FACD  |.  E8 466CFDFF   call Acid_bur.00406718                   ;  将上一次计算结果的十进制转为字符串</span><br><span class="line">0042FAD2  |.  FF75 E8       push [local.6]</span><br><span class="line">0042FAD5  |.  68 C8FB4200   push Acid_bur.0042FBC8                   ;  -</span><br><span class="line">0042FADA  |.  FF75 F8       push [local.2]                           ;  Acid_bur.0042FBB8</span><br><span class="line">0042FADD  |.  8D45 F4       lea eax,[local.3]</span><br><span class="line">0042FAE0  |.  BA 05000000   mov edx,0x5</span><br><span class="line">0042FAE5  |.  E8 C23EFDFF   call Acid_bur.004039AC                   ;  获取正确注册码</span><br><span class="line">0042FAEA  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">0042FAED  |.  8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]</span><br><span class="line">0042FAF3  |.  E8 60AFFEFF   call Acid_bur.0041AA58                   ;  获取输入假码</span><br><span class="line">0042FAF8  |.  8B55 F0       mov edx,[local.4]                        ;  假码</span><br><span class="line">0042FAFB  |.  8B45 F4       mov eax,[local.3]                        ;  真码</span><br><span class="line">0042FAFE  |.  E8 F93EFDFF   call Acid_bur.004039FC                   ;  验证函数</span><br><span class="line">0042FB03  |.  75 1A         jnz short Acid_bur.0042FB1F              ;  跳转为注册失败，不跳转为注册成功</span><br></pre></td></tr></table></figure><p>分析注册算法为：</p><ol><li>判断用户名的长度是否大于等于4。</li><li><p>用户名第一个字符的ascii码 * 0x29。</p></li><li><p>第一步结果与自己相加，即乘2。</p></li><li><p>将第二步结果的十进制用字符串表示。</p></li><li><p>连接字符串<code>CW-&lt;第三步字符串&gt;-CRACKED</code>。</p></li></ol><p>例如用户名为<strong>test</strong>，则注册码为<strong>CW-9512-CRACKED</strong>。</p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-264393-1-1.html" target="_blank" rel="noopener">[反汇编练习]160个CrackMe之001</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第1个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之003</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B003/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之003/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:47:07.309Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第三个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：AfKayAs.2.exe</li><li>工具：PEiD v095、吾爱破解专用版OllyDbg</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，提示需要完成两个目标。</p><ol><li><p>去除 Nag 窗口。</p></li><li><p>找到成功注册的用户名和注册码。</p></li></ol><p>首先进行查壳，无壳，Microsoft Visual Basic 编写。</p><p><strong>目标1：去除Nag窗口</strong></p><p>针对 VB 5.0 程序，采用刚刚从吾爱学习到的4C法。</p><p>载入OD后，入口为 push 指令，和 call 指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401170 &gt; $  68 D4674000   push AfKayAs_.004067D4</span><br><span class="line">00401175   .  E8 F0FFFFFF   call &lt;jmp.&amp;MSVBVM50.#ThunRTMain_100&gt;</span><br></pre></td></tr></table></figure><p>将 push 指令后的操作数加上 0x4C，作为数据窗口跟随的地址，即 0x00406820。</p><p>继续跟随 0x00406820 处的DWORD类型的值 0x00406868。</p><p>其中标记的数据是VB需要加载的两块代码（即加载的窗体代码），每块代码的第24字节处是该代码块被加载的顺序。第一块为 0x00（Nag窗口），第二块为 0x01（注册窗口）。</p><p>将两块代码的加载顺序互换，即第一块为 0x01，第二块为 0x00。代表首先加载注册窗口的代码，而注册窗口关闭后，程序退出，所以Nag窗口实际上不会被执行，即被去除。</p><p><strong>目标2：找到成功注册的用户名和注册码</strong></p><p>输入任意用户名和注册码，获得失败提示。</p><p>载入OD，搜索字符串，确定失败字符串，找到关键跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00408665   .  66:85F6       test si,si</span><br><span class="line">00408668   .  8945 94       mov dword ptr ss:[ebp-0x6C],eax</span><br><span class="line">0040866B   .  894D AC       mov dword ptr ss:[ebp-0x54],ecx</span><br><span class="line">0040866E   .  8945 A4       mov dword ptr ss:[ebp-0x5C],eax</span><br><span class="line">00408671   .  894D BC       mov dword ptr ss:[ebp-0x44],ecx</span><br><span class="line">00408674   .  8945 B4       mov dword ptr ss:[ebp-0x4C],eax</span><br><span class="line">00408677   .  74 62         je short AfKayAs_.004086DB               ;  跳转为注册失败，不跳转为注册成功</span><br></pre></td></tr></table></figure><p>向上分析，找到比较代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">004085CE   &gt; \8B45 E8       mov eax,dword ptr ss:[ebp-0x18]          ;  取出输入的注册码</span><br><span class="line">004085D1   .  50            push eax</span><br><span class="line">004085D2   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  msvbvm50.__vbaR8Str</span><br><span class="line">004085D8   .  8B4D E4       mov ecx,dword ptr ss:[ebp-0x1C]          ;  取出正确的注册码</span><br><span class="line">004085DB   .  DD9D 1CFFFFFF fstp qword ptr ss:[ebp-0xE4]             ;  假码放入内存作为除数</span><br><span class="line">004085E1   .  51            push ecx</span><br><span class="line">004085E2   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  msvbvm50.__vbaR8Str</span><br><span class="line">004085E8   .  833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0</span><br><span class="line">004085EF   .  75 08         jnz short AfKayAs_.004085F9</span><br><span class="line">004085F1   .  DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4]            ;  真码除以假码</span><br><span class="line">004085F7   .  EB 11         jmp short AfKayAs_.0040860A</span><br><span class="line">004085F9   &gt;  FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0]</span><br><span class="line">004085FF   .  FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4]</span><br><span class="line">00408605   .  E8 888AFFFF   call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt;</span><br><span class="line">0040860A   &gt;  DFE0          fstsw ax</span><br><span class="line">0040860C   .  A8 0D         test al,0xD</span><br><span class="line">0040860E   .  0F85 AB010000 jnz AfKayAs_.004087BF</span><br><span class="line">00408614   .  FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt;;  msvbvm50.__vbaFpR8</span><br><span class="line">0040861A   .  DC1D 28104000 fcomp qword ptr ds:[0x401028]            ;  比较运算结果是否为1</span><br><span class="line">00408620   .  DFE0          fstsw ax</span><br><span class="line">00408622   .  F6C4 40       test ah,0x40</span><br><span class="line">00408625   .  74 07         je short AfKayAs_.0040862E</span><br><span class="line">00408627   .  BE 01000000   mov esi,0x1                              ;  注册标志置1</span><br><span class="line">0040862C   .  EB 02         jmp short AfKayAs_.00408630</span><br><span class="line">0040862E   &gt;  33F6          xor esi,esi                              ;  注册标志置0</span><br></pre></td></tr></table></figure><p>继续向上，找到计算注册码的算法，共有四块代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">004081E9   &gt; \8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]</span><br><span class="line">004081EF   .  8B45 E4       mov eax,dword ptr ss:[ebp-0x1C]          ;  取出用户名</span><br><span class="line">004081F2   .  50            push eax                                 ; /String = &quot;355668&quot;</span><br><span class="line">004081F3   .  8B1A          mov ebx,dword ptr ds:[edx]               ; |</span><br><span class="line">004081F5   .  FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \__vbaLenBstr</span><br><span class="line">004081FB   .  8BF8          mov edi,eax</span><br><span class="line">004081FD   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]</span><br><span class="line">00408200   .  69FF 385B0100 imul edi,edi,0x15B38                     ;  用户名长度 乘以 0x15B38</span><br><span class="line">00408206   .  51            push ecx                                 ; /String = &quot;\^&quot;</span><br><span class="line">00408207   .  0F80 B7050000 jo AfKayAs_.004087C4                     ; |</span><br><span class="line">0040820D   .  FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr</span><br><span class="line">00408213   .  0FBFD0        movsx edx,ax                             ;  获取用户名第一个字符的ASCII码</span><br><span class="line">00408216   .  03FA          add edi,edx                              ;  加上前面的乘法结果</span><br><span class="line">00408218   .  0F80 A6050000 jo AfKayAs_.004087C4</span><br><span class="line">0040821E   .  57            push edi</span><br><span class="line">0040821F   .  FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;;  msvbvm50.__vbaStrI4</span><br><span class="line">00408225   .  8BD0          mov edx,eax                              ;  转为十进制表示的字符串</span><br><span class="line">00408227   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]</span><br><span class="line">0040822A   .  FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;;  msvbvm50.__vbaStrMove</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">004082DD   &gt; \8B8D 58FFFFFF mov ecx,dword ptr ss:[ebp-0xA8]</span><br><span class="line">004082E3   .  8B55 E8       mov edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004082E6   .  52            push edx</span><br><span class="line">004082E7   .  8B19          mov ebx,dword ptr ds:[ecx]</span><br><span class="line">004082E9   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  msvbvm50.__vbaR8Str</span><br><span class="line">004082EF   .  D905 08104000 fld dword ptr ds:[0x401008]              ;  压入 0x10</span><br><span class="line">004082F5   .  833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0</span><br><span class="line">004082FC   .  75 08         jnz short AfKayAs_.00408306</span><br><span class="line">004082FE   .  D835 0C104000 fdiv dword ptr ds:[0x40100C]             ;  0x10 除以 0x5</span><br><span class="line">00408304   .  EB 0B         jmp short AfKayAs_.00408311</span><br><span class="line">00408306   &gt;  FF35 0C104000 push dword ptr ds:[0x40100C]</span><br><span class="line">0040830C   .  E8 578DFFFF   call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt;</span><br><span class="line">00408311   &gt;  83EC 08       sub esp,0x8</span><br><span class="line">00408314   .  DFE0          fstsw ax</span><br><span class="line">00408316   .  A8 0D         test al,0xD</span><br><span class="line">00408318   .  0F85 A1040000 jnz AfKayAs_.004087BF</span><br><span class="line">0040831E   .  DEC1          faddp st(1),st                           ;  加上前面的除法结果，即 0x2</span><br><span class="line">00408320   .  DFE0          fstsw ax</span><br><span class="line">00408322   .  A8 0D         test al,0xD</span><br><span class="line">00408324   .  0F85 95040000 jnz AfKayAs_.004087BF</span><br><span class="line">0040832A   .  DD1C24        fstp qword ptr ss:[esp]</span><br><span class="line">0040832D   .  FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;;  msvbvm50.__vbaStrR8</span><br><span class="line">00408333   .  8BD0          mov edx,eax</span><br><span class="line">00408335   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]</span><br><span class="line">00408338   .  FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;;  msvbvm50.__vbaStrMove</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">004083E9   &gt; \8B8D 58FFFFFF mov ecx,dword ptr ss:[ebp-0xA8]</span><br><span class="line">004083EF   .  8B55 E8       mov edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004083F2   .  52            push edx</span><br><span class="line">004083F3   .  8B19          mov ebx,dword ptr ds:[ecx]</span><br><span class="line">004083F5   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  msvbvm50.__vbaR8Str</span><br><span class="line">004083FB   .  DC0D 10104000 fmul qword ptr ds:[0x401010]             ;  乘以 0x3</span><br><span class="line">00408401   .  83EC 08       sub esp,0x8</span><br><span class="line">00408404   .  DC25 18104000 fsub qword ptr ds:[0x401018]             ;  减去 0x2</span><br><span class="line">0040840A   .  DFE0          fstsw ax</span><br><span class="line">0040840C   .  A8 0D         test al,0xD</span><br><span class="line">0040840E   .  0F85 AB030000 jnz AfKayAs_.004087BF</span><br><span class="line">00408414   .  DD1C24        fstp qword ptr ss:[esp]</span><br><span class="line">00408417   .  FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;;  msvbvm50.__vbaStrR8</span><br><span class="line">0040841D   .  8BD0          mov edx,eax</span><br><span class="line">0040841F   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]</span><br><span class="line">00408422   .  FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;;  msvbvm50.__vbaStrMove</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">004084D3   &gt; \8B8D 58FFFFFF mov ecx,dword ptr ss:[ebp-0xA8]</span><br><span class="line">004084D9   .  8B55 E8       mov edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004084DC   .  52            push edx</span><br><span class="line">004084DD   .  8B19          mov ebx,dword ptr ds:[ecx]</span><br><span class="line">004084DF   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  msvbvm50.__vbaR8Str</span><br><span class="line">004084E5   .  DC25 20104000 fsub qword ptr ds:[0x401020]             ;  加 0x15</span><br><span class="line">004084EB   .  83EC 08       sub esp,0x8</span><br><span class="line">004084EE   .  DFE0          fstsw ax</span><br><span class="line">004084F0   .  A8 0D         test al,0xD</span><br><span class="line">004084F2   .  0F85 C7020000 jnz AfKayAs_.004087BF</span><br><span class="line">004084F8   .  DD1C24        fstp qword ptr ss:[esp]</span><br><span class="line">004084FB   .  FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;;  msvbvm50.__vbaStrR8</span><br><span class="line">00408501   .  8BD0          mov edx,eax                              ;  得到正确的注册码</span><br><span class="line">00408503   .  8D4D E4       lea ecx,dword ptr ss:[ebp-0x1C]</span><br><span class="line">00408506   .  FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;;  msvbvm50.__vbaStrMove</span><br></pre></td></tr></table></figure><p>整个计算过程很简单：</p><ol><li>用户名的长度与 * 0x15B38 。</li><li>用户名第一个字符的ASCII码 + 第一步结果，结果转为十进制表示的十六进制。</li><li>第二步结果 + 0x10 / 0x5。</li><li>第三步结果 * 0x3 - 0x2。</li><li>第四步结果 + 0x15 。</li><li>第五步结果转为字符串。</li></ol><p>例如：用户名为“test”，计算过程为：</p><ol><li>0x4 * 0x15B38 = 0x56CE0。</li><li>0x56CE0 + 0x74 = 0x56D54（355668），转为 0x355668。</li><li>0x355668 + 0x10 / 0x5 = 0x355670。</li><li>0x355670 * 0x3 - 0x2 = 0x1067008。</li><li>0x1067008 + 0x15 = 0x1067023。</li></ol><p>注册码为”1067023”。</p><p>输入用户名和注册码验证。</p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-264605-1-1.html" target="_blank" rel="noopener">[反汇编练习] 160个CrackMe之003 (出处: 吾爱破解论坛)</a></li><li><a href="https://www.52pojie.cn/thread-612982-1-1.html" target="_blank" rel="noopener">160个crackme之003 Afkayas 去VB程序NAG窗口方法-4C法 (出处: 吾爱破解论坛)</a></li><li><a href="https://www.52pojie.cn/thread-338571-1-1.html" target="_blank" rel="noopener">完全新手教程：使用OllyDbg从零开始Cracking (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第三个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之006</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B006/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之006/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:49:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第6个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：aLoNg3x.1.exe</li><li>工具：PEiD v0.95、吾爱破解专用版OllyDbg、DeDe v3.50.04</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，需要用户名和注册码，且OK按钮是不可点击的。</p><p><img src="注册界面.png" alt="注册界面"></p><p>PEiD查壳，无壳，Borland Delphi 编写。</p><p><img src="PEiD查壳.png" alt="PEiD查壳"></p><p>Delphi程序，拖入DeDe查看。找到10个过程事件函数。</p><p><img src="过程事件函数列表.png" alt="过程事件函数列表"></p><p>因为OK按钮无法使用，所以程序应该是每次输入来检测用户名和注册码的。所以先分析“NomeChange”和“CodiceChange”函数。</p><p><strong>1.NomeChange</strong></p><p>函数逻辑很简单，验证Nome和Codice，通过则更改OK按钮为可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00442E37  |&gt; \8D55 FC       lea edx,[local.1]</span><br><span class="line">00442E3A  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442E40  |.  E8 7B04FEFF   call aLoNg3x_.004232C0                   ;  获取Codice</span><br><span class="line">00442E45  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442E48  |.  50            push eax</span><br><span class="line">00442E49  |.  8D55 F8       lea edx,[local.2]</span><br><span class="line">00442E4C  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442E52  |.  E8 6904FEFF   call aLoNg3x_.004232C0                   ;  获取Nome</span><br><span class="line">00442E57  |.  8B45 F8       mov eax,[local.2]</span><br><span class="line">00442E5A  |.  5A            pop edx                                  ;  0012F3CC</span><br><span class="line">00442E5B  |.  E8 DCFBFFFF   call aLoNg3x_.00442A3C                   ;  验证Nome和Codice</span><br><span class="line">00442E60  |.  84C0          test al,al</span><br><span class="line">00442E62  |.  74 0F         je short aLoNg3x_.00442E73</span><br><span class="line">00442E64  |.  B2 01         mov dl,0x1</span><br><span class="line">00442E66  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]</span><br><span class="line">00442E6C  |.  8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">00442E6E  |.  FF51 60       call dword ptr ds:[ecx+0x60]             ;  更改OK按钮为可用</span><br><span class="line">00442E71  |.  EB 0D         jmp short aLoNg3x_.00442E80</span><br><span class="line">00442E73  |&gt;  33D2          xor edx,edx</span><br><span class="line">00442E75  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]</span><br><span class="line">00442E7B  |.  8B08          mov ecx,dword ptr ds:[eax]</span><br><span class="line">00442E7D  |.  FF51 60       call dword ptr ds:[ecx+0x60]             ;  更改OK按钮为不可用</span><br><span class="line">00442E80  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>对验证函数 “_PROC_00442A3C” 进行分析。</p><p><strong>2._PROC_00442A3C</strong></p><p>首先检测Nome长度是否大于5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00442A68  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442A6B  |.  E8 C40FFCFF   call aLoNg3x_.00403A34                   ;  计算用户名长度</span><br><span class="line">00442A70  |.  83F8 05       cmp eax,0x5</span><br><span class="line">00442A73  |.  7E 53         jle short aLoNg3x_.00442AC8              ;  用户名长度需要大于5</span><br></pre></td></tr></table></figure><p>根据Nome计算出验证码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00442A89  |.  4A            dec edx</span><br><span class="line">00442A8A  |.  85D2          test edx,edx</span><br><span class="line">00442A8C  |.  7E 20         jle short aLoNg3x_.00442AAE</span><br><span class="line">00442A8E  |.  B8 01000000   mov eax,0x1</span><br><span class="line">00442A93  |&gt;  8B4D FC       /mov ecx,[local.1]</span><br><span class="line">00442A96  |.  0FB64C01 FF   |movzx ecx,byte ptr ds:[ecx+eax-0x1]</span><br><span class="line">00442A9B  |.  8B75 FC       |mov esi,[local.1]</span><br><span class="line">00442A9E  |.  0FB63406      |movzx esi,byte ptr ds:[esi+eax]</span><br><span class="line">00442AA2  |.  0FAFCE        |imul ecx,esi</span><br><span class="line">00442AA5  |.  0FAFC8        |imul ecx,eax</span><br><span class="line">00442AA8  |.  03D9          |add ebx,ecx</span><br><span class="line">00442AAA  |.  40            |inc eax</span><br><span class="line">00442AAB  |.  4A            |dec edx</span><br><span class="line">00442AAC  |.^ 75 E5         \jnz short aLoNg3x_.00442A93</span><br></pre></td></tr></table></figure><p>计算流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> code = <span class="built_in">strlen</span>(Nome);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(Nome) - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">code += Nome[i] * Nome[i+<span class="number">1</span>] * (i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Codice相减，进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00442AAE  |&gt; \8B45 F8       mov eax,[local.2]</span><br><span class="line">00442AB1  |.  E8 BA4BFCFF   call aLoNg3x_.00407670                   ;  转为十六进制</span><br><span class="line">00442AB6  |.  2BD8          sub ebx,eax</span><br><span class="line">00442AB8  |.  81FB 9A020000 cmp ebx,0x29A                            ;  Codice与验证码相差 0x29A</span><br><span class="line">00442ABE  |.  75 04         jnz short aLoNg3x_.00442AC4</span><br><span class="line">00442AC0  |.  B3 01         mov bl,0x1</span><br><span class="line">00442AC2  |.  EB 06         jmp short aLoNg3x_.00442ACA</span><br></pre></td></tr></table></figure><p>例如Nome为“tested”，则Codice为“171670”。</p><p>Nome与Codice正确之后，OK按钮变得可用。接着分析“OkClick”函数。</p><p><strong>3.OkClick</strong></p><p>检测某个标志，不通过则清除Codice，通过则隐藏OK按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00442D7A  |.  8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]</span><br><span class="line">00442D80  |.  8078 47 01    cmp byte ptr ds:[eax+0x47],0x1           ;  检测标志</span><br><span class="line">00442D84  |.  75 12         jnz short aLoNg3x_.00442D98</span><br></pre></td></tr></table></figure><p>搜索常量 0x2D0，最终确定在 “CancellaClick”函数中可以修改该标志。</p><p>验证Nome与Codice。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00442D98  |&gt; \8D55 FC       lea edx,[local.1]</span><br><span class="line">00442D9B  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442DA1  |.  E8 1A05FEFF   call aLoNg3x_.004232C0                   ;  获取Codice</span><br><span class="line">00442DA6  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442DA9  |.  E8 C248FCFF   call aLoNg3x_.00407670                   ;  转为十六进制</span><br><span class="line">00442DAE  |.  50            push eax</span><br><span class="line">00442DAF  |.  8D55 FC       lea edx,[local.1]</span><br><span class="line">00442DB2  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442DB8  |.  E8 0305FEFF   call aLoNg3x_.004232C0                   ;  获取Nome</span><br><span class="line">00442DBD  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442DC0  |.  5A            pop edx                                  ;  0012F97C</span><br><span class="line">00442DC1  |.  E8 DAFDFFFF   call aLoNg3x_.00442BA0                   ;  验证Nome与Codice</span><br><span class="line">00442DC6  |.  84C0          test al,al</span><br><span class="line">00442DC8  |.  74 0D         je short aLoNg3x_.00442DD7               ;  跳转为验证失败，不跳转为验证成功</span><br></pre></td></tr></table></figure><p>验证函数为”_PROC_00442BA0”。</p><p><strong>4.CancellaClick</strong></p><p>函数中对Nome和Codice进行了验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00442EBE  |.  8D55 FC       lea edx,[local.1]</span><br><span class="line">00442EC1  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442EC7  |.  E8 F403FEFF   call aLoNg3x_.004232C0                   ;  获取Codice</span><br><span class="line">00442ECC  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442ECF  |.  E8 9C47FCFF   call aLoNg3x_.00407670                   ;  转为十六进制</span><br><span class="line">00442ED4  |.  50            push eax</span><br><span class="line">00442ED5  |.  8D55 FC       lea edx,[local.1]</span><br><span class="line">00442ED8  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442EDE  |.  E8 DD03FEFF   call aLoNg3x_.004232C0                   ;  获取Nome</span><br><span class="line">00442EE3  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442EE6  |.  5A            pop edx                                  ;  0012F674</span><br><span class="line">00442EE7  |.  E8 08FCFFFF   call aLoNg3x_.00442AF4                   ;  比较Nome和Codice</span><br><span class="line">00442EEC  |.  84C0          test al,al</span><br><span class="line">00442EEE  |.  74 1C         je short aLoNg3x_.00442F0C               ;  跳转为验证失败，不跳转为验证成功</span><br></pre></td></tr></table></figure><p>对验证函数 “_PROC_00442AF4”进行分析。</p><p><strong>5._PROC_00442AF4</strong></p><p>检查Nome长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00442B18  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442B1B  |.  E8 140FFCFF   call aLoNg3x_.00403A34                   ;  计算Nome长度</span><br><span class="line">00442B20  |.  83F8 05       cmp eax,0x5</span><br><span class="line">00442B23  |.  7E 53         jle short aLoNg3x_.00442B78              ;  Nome长度必须大于5</span><br></pre></td></tr></table></figure><p>计算key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00442B18  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442B1B  |.  E8 140FFCFF   call aLoNg3x_.00403A34                   ;  计算Nome长度</span><br><span class="line">00442B20  |.  83F8 05       cmp eax,0x5</span><br><span class="line">00442B23  |.  7E 53         jle short aLoNg3x_.00442B78              ;  Nome长度必须大于5</span><br><span class="line">00442B25  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442B28  |.  0FB640 04     movzx eax,byte ptr ds:[eax+0x4]          ;  Nome第二位</span><br><span class="line">00442B2C  |.  B9 07000000   mov ecx,0x7</span><br><span class="line">00442B31  |.  33D2          xor edx,edx</span><br><span class="line">00442B33  |.  F7F1          div ecx                                  ;  Nome[1] / 0x7</span><br><span class="line">00442B35  |.  8BC2          mov eax,edx                              ;  取余数</span><br><span class="line">00442B37  |.  83C0 02       add eax,0x2 ;余数 + 0x2</span><br><span class="line">00442B3A  |.  E8 E1FEFFFF   call aLoNg3x_.00442A20                   ;  阶乘</span><br></pre></td></tr></table></figure><p>计算验证码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00442B43  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442B46  |.  E8 E90EFCFF   call aLoNg3x_.00403A34                   ;  计算Nome长度</span><br><span class="line">00442B4B  |.  85C0          test eax,eax</span><br><span class="line">00442B4D  |.  7E 16         jle short aLoNg3x_.00442B65</span><br><span class="line">00442B4F  |.  BA 01000000   mov edx,0x1</span><br><span class="line">00442B54  |&gt;  8B4D FC       /mov ecx,[local.1]</span><br><span class="line">00442B57  |.  0FB64C11 FF   |movzx ecx,byte ptr ds:[ecx+edx-0x1]</span><br><span class="line">00442B5C  |.  0FAFCE        |imul ecx,esi                            ;  Nome每一个字符与key相乘</span><br><span class="line">00442B5F  |.  03D9          |add ebx,ecx</span><br><span class="line">00442B61  |.  42            |inc edx</span><br><span class="line">00442B62  |.  48            |dec eax</span><br><span class="line">00442B63  |.^ 75 EF         \jnz short aLoNg3x_.00442B54</span><br></pre></td></tr></table></figure><p>比较注册码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00442B65  |&gt; \2B5D F8       sub ebx,[local.2]</span><br><span class="line">00442B68  |.  81FB 697A0000 cmp ebx,0x7A69 ;验证码与注册码相差 0x7A69</span><br><span class="line">00442B6E  |.  75 04         jnz short aLoNg3x_.00442B74              ;  跳转为验证失败，不跳转为验证通过</span><br></pre></td></tr></table></figure><p>该函数的算法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> code = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">key = Nome[<span class="number">1</span>] % <span class="number">0x7</span> + <span class="number">0x2</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(Nome); i++)</span><br><span class="line">&#123;</span><br><span class="line">code += Nome[i] * key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，Nome为“tested”，Codice为”46543”。</p><p><strong>6._PROC_00442BA0</strong></p><p>检测Codice长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00442BDD  |.  8B45 F8       mov eax,[local.2]</span><br><span class="line">00442BE0  |.  E8 4F0EFCFF   call aLoNg3x_.00403A34                   ;  计算Codice长度</span><br><span class="line">00442BE5  |.  83F8 05       cmp eax,0x5</span><br><span class="line">00442BE8  |.  7E 60         jle short aLoNg3x_.00442C4A              ;  Codice长度必须大于5</span><br></pre></td></tr></table></figure><p>将Codice变换为大写字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00442BF9  |&gt; /8D45 F4       /lea eax,[local.3]</span><br><span class="line">00442BFC  |. |E8 0310FCFF   |call aLoNg3x_.00403C04</span><br><span class="line">00442C01  |. |8D4430 FF     |lea eax,dword ptr ds:[eax+esi-0x1]      ;  指向Codice最后一个字符</span><br><span class="line">00442C05  |. |50            |push eax</span><br><span class="line">00442C06  |. |8B45 F8       |mov eax,[local.2]</span><br><span class="line">00442C09  |. |0FB64430 FF   |movzx eax,byte ptr ds:[eax+esi-0x1]     ;  从Codice末尾开始依次取出字符</span><br><span class="line">00442C0E  |. |F7E8          |imul eax                                ;  平方</span><br><span class="line">00442C10  |. |0FBFC0        |movsx eax,ax</span><br><span class="line">00442C13  |. |F7EE          |imul esi                                ;  乘以本身的位置</span><br><span class="line">00442C15  |. |B9 19000000   |mov ecx,0x19</span><br><span class="line">00442C1A  |. |99            |cdq</span><br><span class="line">00442C1B  |. |F7F9          |idiv ecx</span><br><span class="line">00442C1D  |. |83C2 41       |add edx,0x41</span><br><span class="line">00442C20  |. |58            |pop eax                                 ;  0012F674</span><br><span class="line">00442C21  |. |8810          |mov byte ptr ds:[eax],dl</span><br><span class="line">00442C23  |. |4E            |dec esi</span><br><span class="line">00442C24  |. |85F6          |test esi,esi</span><br><span class="line">00442C26  |.^\75 D1         \jnz short aLoNg3x_.00442BF9</span><br></pre></td></tr></table></figure><p>与Nome比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00442C28  |&gt; \8B45 F4       mov eax,[local.3]</span><br><span class="line">00442C2B  |.  8B55 FC       mov edx,[local.1]</span><br><span class="line">00442C2E  |.  E8 110FFCFF   call aLoNg3x_.00403B44</span><br><span class="line">00442C33  |.  75 17         jnz short aLoNg3x_.00442C4C              ;  跳转为验证失败，不跳转为验证成功</span><br></pre></td></tr></table></figure><p>例如，Codice为“123456”，Nome为“BADQUV”。</p><p>所以整个验证过程为：</p><ol><li>输入Nome=”tested”，Codice=”46543”；</li><li>点击Cancella按钮，该按钮会消失，OK按钮显示可用；</li><li>输入Nome=”BADQUV”，Codice=”123456”；</li><li>点击OK按钮，该按钮也消失，注册成功。</li></ol><p><img src="注册成功.png" alt="注册成功"></p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-610580-1-1.html" target="_blank" rel="noopener">初练160个CrakeMe程序之006 (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第6个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之007</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B007/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之007/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:50:15.601Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第7个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：aLoNg3x.2.exe</li><li>工具：PEiD v0.95、吾爱破解专用版OllyDbg、DeDe v3.50.04</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，查看作者提示，最终需要将注册按钮隐藏起来。</p><p><img src="注册界面.png" alt="注册界面"></p><p>PEiD查壳，无壳，Borland Delphi 编写。</p><p><img src="PEiD查壳.png" alt="PEiD查壳"></p><p>拖入DeDe进行反编译，找到9个过程事件函数。</p><p><img src="过程事件函数列表.png" alt="过程事件函数列表"></p><p>不输入任何注册名和注册码，可以得到提示。</p><p><img src="输入提示.png" alt="输入提示"></p><p>载入OD搜索字符串，确定在RegisterzClick函数中。</p><p><strong>1.RegisterzClick</strong></p><p>检测注册码是否有效，并验证注册名和注册码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">00442F45  |.  8D55 F8       lea edx,[local.2]</span><br><span class="line">00442F48  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442F4E  |.  E8 ED02FEFF   call aLoNg3x_.00423240                   ;  获取注册码</span><br><span class="line">00442F53  |.  8B45 F8       mov eax,[local.2]</span><br><span class="line">00442F56  |.  8D55 FC       lea edx,[local.1]</span><br><span class="line">00442F59  |.  E8 FAF9FBFF   call aLoNg3x_.00402958                   ;  转为十六进制</span><br><span class="line">00442F5E  |.  8BF0          mov esi,eax</span><br><span class="line">00442F60  |.  837D FC 00    cmp [local.1],0x0                        ;  判断注册码是否为有效输入</span><br><span class="line">00442F64  |.  74 37         je short aLoNg3x_.00442F9D</span><br><span class="line">00442F66  |.  B8 38304400   mov eax,aLoNg3x_.00443038                ;  You MUST insert a valid Long Integer Value in the Code Editor... Thank you :)</span><br><span class="line">00442F6B  |.  E8 00F6FFFF   call aLoNg3x_.00442570                   ;  弹出提示框</span><br><span class="line">00442F70  |.  8D55 F8       lea edx,[local.2]</span><br><span class="line">00442F73  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442F79  |.  E8 C202FEFF   call aLoNg3x_.00423240                   ;  计算注册码长度</span><br><span class="line">00442F7E  |.  8B45 F8       mov eax,[local.2]</span><br><span class="line">00442F81  |.  E8 06FBFFFF   call aLoNg3x_.00442A8C                   ;  计算key</span><br><span class="line">00442F86  |.  A3 30584400   mov dword ptr ds:[0x445830],eax</span><br><span class="line">00442F8B  |.  BA 90304400   mov edx,aLoNg3x_.00443090                ;  0</span><br><span class="line">00442F90  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442F96  |.  E8 D502FEFF   call aLoNg3x_.00423270                   ;  清空注册码框内容</span><br><span class="line">00442F9B  |.  EB 6F         jmp short aLoNg3x_.0044300C</span><br><span class="line">00442F9D  |&gt;  85F6          test esi,esi                             ;  判断注册码是否为空</span><br><span class="line">00442F9F  |.  7E 5A         jle short aLoNg3x_.00442FFB</span><br><span class="line">00442FA1  |.  8D55 F8       lea edx,[local.2]</span><br><span class="line">00442FA4  |.  8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8]</span><br><span class="line">00442FAA  |.  E8 9102FEFF   call aLoNg3x_.00423240                   ;  获取注册名</span><br><span class="line">00442FAF  |.  8B4D F8       mov ecx,[local.2]</span><br><span class="line">00442FB2  |.  8BD6          mov edx,esi</span><br><span class="line">00442FB4  |.  A1 30584400   mov eax,dword ptr ds:[0x445830]</span><br><span class="line">00442FB9  |.  E8 EAF9FFFF   call aLoNg3x_.004429A8                   ;  验证注册名和注册码</span><br><span class="line">00442FBE  |.  84C0          test al,al</span><br><span class="line">00442FC0  |.  74 30         je short aLoNg3x_.00442FF2</span><br></pre></td></tr></table></figure><p>验证函数 _PROC_004429A8有三个参数，依次是：保存在 0x445830 的key、注册码的十六进制表示、注册名。</p><p>第一个参数key默认为0，由 _PROC_00442A8C 函数计算出。想运行到该函数，需要先输入无效的注册码，key由该无效的注册码计算出。</p><p>验证通过后隐藏Register按钮，显示again!!!按钮。</p><p><strong>2._PROC_00442A8C</strong></p><p>循环计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">00442AB9  |.  BE 7B030000   mov esi,0x37B</span><br><span class="line">00442ABE  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442AC1  |.  E8 6E0FFCFF   call aLoNg3x_.00403A34</span><br><span class="line">00442AC6  |.  8BD8          mov ebx,eax</span><br><span class="line">00442AC8  |.  4B            dec ebx</span><br><span class="line">00442AC9  |.  85DB          test ebx,ebx</span><br><span class="line">00442ACB  |.  7E 2B         jle short aLoNg3x_.00442AF8</span><br><span class="line">00442ACD  |.  B9 01000000   mov ecx,0x1</span><br><span class="line">00442AD2  |&gt;  8B45 FC       /mov eax,[local.1]</span><br><span class="line">00442AD5  |.  0FB60408      |movzx eax,byte ptr ds:[eax+ecx]</span><br><span class="line">00442AD9  |.  BF 11000000   |mov edi,0x11</span><br><span class="line">00442ADE  |.  33D2          |xor edx,edx</span><br><span class="line">00442AE0  |.  F7F7          |div edi</span><br><span class="line">00442AE2  |.  42            |inc edx</span><br><span class="line">00442AE3  |.  8B45 FC       |mov eax,[local.1]</span><br><span class="line">00442AE6  |.  0FB64408 FF   |movzx eax,byte ptr ds:[eax+ecx-0x1]</span><br><span class="line">00442AEB  |.  0FAFD0        |imul edx,eax</span><br><span class="line">00442AEE  |.  03F2          |add esi,edx</span><br><span class="line">00442AF0  |.  41            |inc ecx</span><br><span class="line">00442AF1  |.  4B            |dec ebx</span><br><span class="line">00442AF2  |.^ 75 DE         \jnz short aLoNg3x_.00442AD2</span><br><span class="line">00442AF4  |.  EB 02         jmp short aLoNg3x_.00442AF8</span><br><span class="line">00442AF6  |&gt;  33F6          xor esi,esi</span><br><span class="line">00442AF8  |&gt;  8BC6          mov eax,esi</span><br><span class="line">00442AFA  |.  B9 48710000   mov ecx,0x7148</span><br><span class="line">00442AFF  |.  99            cdq</span><br><span class="line">00442B00  |.  F7F9          idiv ecx</span><br><span class="line">00442B02  |.  8BC2          mov eax,edx</span><br><span class="line">00442B04  |.  99            cdq</span><br><span class="line">00442B05  |.  33C2          xor eax,edx</span><br><span class="line">00442B07  |.  2BC2          sub eax,edx</span><br><span class="line">00442B09  |.  8BD8          mov ebx,eax</span><br><span class="line">00442B0B  |.  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>对应算法伪代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0x37B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(Codice); i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += (Codice[i] % <span class="number">0x11</span> + <span class="number">0x1</span>) * Codice[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = sum % <span class="number">0x7148</span>;</span><br></pre></td></tr></table></figure><p><strong>3._PROC_004429A8</strong></p><p>得到key之后，就可以正常进行验证计算了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">004429EE  |.  8945 F4       mov [local.3],eax</span><br><span class="line">004429F1  |.  BE 01000000   mov esi,0x1</span><br><span class="line">004429F6  |&gt;  8B45 F8       /mov eax,[local.2]</span><br><span class="line">004429F9  |.  E8 3610FCFF   |call aLoNg3x_.00403A34</span><br><span class="line">004429FE  |.  83F8 01       |cmp eax,0x1</span><br><span class="line">00442A01  |.  7C 1D         |jl short aLoNg3x_.00442A20</span><br><span class="line">00442A03  |&gt;  8B55 F8       |/mov edx,[local.2]</span><br><span class="line">00442A06  |.  0FB65432 FF   ||movzx edx,byte ptr ds:[edx+esi-0x1]    ;  从注册名开头取字符</span><br><span class="line">00442A0B  |.  8B4D F8       ||mov ecx,[local.2]</span><br><span class="line">00442A0E  |.  0FB64C01 FF   ||movzx ecx,byte ptr ds:[ecx+eax-0x1]    ;  从注册名末尾取字符</span><br><span class="line">00442A13  |.  0FAFD1        ||imul edx,ecx</span><br><span class="line">00442A16  |.  0FAFD7        ||imul edx,edi</span><br><span class="line">00442A19  |.  03DA          ||add ebx,edx</span><br><span class="line">00442A1B  |.  48            ||dec eax</span><br><span class="line">00442A1C  |.  85C0          ||test eax,eax</span><br><span class="line">00442A1E  |.^ 75 E3         |\jnz short aLoNg3x_.00442A03</span><br><span class="line">00442A20  |&gt;  46            |inc esi</span><br><span class="line">00442A21  |.  FF4D F4       |dec [local.3]</span><br><span class="line">00442A24  |.^ 75 D0         \jnz short aLoNg3x_.004429F6</span><br><span class="line">00442A26  |&gt;  8BC3          mov eax,ebx</span><br><span class="line">00442A28  |.  99            cdq</span><br><span class="line">00442A29  |.  33C2          xor eax,edx</span><br><span class="line">00442A2B  |.  2BC2          sub eax,edx</span><br><span class="line">00442A2D  |.  B9 2A2C0A00   mov ecx,0xA2C2A</span><br><span class="line">00442A32  |.  99            cdq</span><br><span class="line">00442A33  |.  F7F9          idiv ecx</span><br><span class="line">00442A35  |.  8BDA          mov ebx,edx</span><br><span class="line">00442A37  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442A3A  |.  B9 59000000   mov ecx,0x59</span><br><span class="line">00442A3F  |.  99            cdq</span><br><span class="line">00442A40  |.  F7F9          idiv ecx</span><br><span class="line">00442A42  |.  8BC8          mov ecx,eax</span><br><span class="line">00442A44  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00442A47  |.  BE 50000000   mov esi,0x50</span><br><span class="line">00442A4C  |.  99            cdq</span><br><span class="line">00442A4D  |.  F7FE          idiv esi</span><br><span class="line">00442A4F  |.  03CA          add ecx,edx</span><br><span class="line">00442A51  |.  41            inc ecx</span><br></pre></td></tr></table></figure><p>算法伪代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">DWORD sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(Nome); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="built_in">strlen</span>(Nome) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">sum += Nome[i] * Nome[j] * key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="built_in">abs</span>(sum) % <span class="number">0xA2C2A</span>;</span><br><span class="line">codice = codice / <span class="number">0x59</span> + codice % <span class="number">0x50</span> + <span class="number">0x1</span></span><br></pre></td></tr></table></figure><p>‭最后比较两个结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00442A52  |.  894D FC       mov [local.1],ecx</span><br><span class="line">00442A55  |.  3B5D FC       cmp ebx,[local.1]</span><br><span class="line">00442A58  |.  75 04         jnz short aLoNg3x_.00442A5E              ;  跳转为验证失败，不跳转为验证成功</span><br><span class="line">00442A5A  |.  B3 01         mov bl,0x1                               ;  设置成功标志为1</span><br><span class="line">00442A5C  |.  EB 06         jmp short aLoNg3x_.00442A64</span><br><span class="line">00442A5E  |&gt;  33DB          xor ebx,ebx                              ;  设置成功标志为0</span><br><span class="line">00442A60  |.  EB 02         jmp short aLoNg3x_.00442A64</span><br><span class="line">00442A62  |&gt;  33DB          xor ebx,ebx</span><br><span class="line">00442A64  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p><strong>4.AgainClick</strong></p><p>该函数的过程与RegisterzClick函数的一样，所以就不再重复了。</p><p>具体的注册方法为：</p><ol><li>输入注册名和用于生成key的注册码，点击Register按钮；</li><li>再次输入用于通过验证的注册码，再次点击Register按钮；</li><li>Register按钮显示，again按钮显示；</li><li>再次重复第一步和第二步，换为点击again按钮。</li></ol><p>可用的注册名和注册码需要进行计算，我使用的为，注册名：tested，生成key的注册码：tested，验证的注册码：28178495。</p><p><img src="注册成功.png" alt="注册成功"></p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-613691-1-1.html" target="_blank" rel="noopener">初练160个CrakeMe程序之007 (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第7个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>160个CrackMe之009</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/CrackMe/160%E4%B8%AACrackMe%E4%B9%8B009/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/CrackMe/160个CrackMe之009/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T02:52:22.714Z</updated>
    
    <content type="html"><![CDATA[<p>160个新手练习CrackMe，第9个。</p><a id="more"></a><h2 id="0x1-环境"><a href="#0x1-环境" class="headerlink" title="0x1 环境"></a>0x1 环境</h2><ul><li>系统：Windows XP SP3</li><li>软件：Andrénalin.2.exe</li><li>工具：PEID v0.95、吾爱破解专用版OllyDbg</li></ul><h2 id="0x2-分析"><a href="#0x2-分析" class="headerlink" title="0x2 分析"></a>0x2 分析</h2><p>运行程序，注册名和注册码验证。</p><p><img src="注册界面.png" alt="注册界面"></p><p>PEiD查壳，无壳，Microsoft Visual Basic 编写</p><p><img src="PEiD查壳.png" alt="PEiD查壳"></p><p>输入任意注册名和注册码，会弹出注册失败提示。</p><p><img src="注册失败.png" alt="注册失败"></p><p>载入OD，搜索字符串，确定失败提示，定位关键跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004022C8   .  66:85DB       test bx,bx</span><br><span class="line">004022CB   .  0F84 C0000000 je Andréna.00402391                      ;  跳转为注册失败，不跳转为注册成功</span><br></pre></td></tr></table></figure><p>向上分析发现验证函数。第一个参数为正确的注册码，第二个参数为输入的假码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0040229E   .  50            push eax                                 ; /var18 = 0012F474</span><br><span class="line">0040229F   .  51            push ecx                                 ; |var28 = 0012F4AC</span><br><span class="line">004022A0   .  C745 A8 00000&gt;mov dword ptr ss:[ebp-0x58],0x0          ; |</span><br><span class="line">004022A7   .  C745 94 08800&gt;mov dword ptr ss:[ebp-0x6C],0x8008       ; |</span><br><span class="line">004022AE   .  FF15 48414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarTs&gt;; \__vbaVarTstEq</span><br></pre></td></tr></table></figure><p>每个参数地址向后第三个DWORD，就是保存的字符串地址。比如 var18 = 0x0012F474，那么 0x0012F47C 处的值就是字符串的起始地址。</p><p>向上分析，找到注册码计算算法。</p><p>首先采用循环将注册名的每一位相加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">004020D5   .  B8 01000000   mov eax,0x1</span><br><span class="line">004020DA   .  8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]</span><br><span class="line">004020E0   .  8985 5CFFFFFF mov dword ptr ss:[ebp-0xA4],eax</span><br><span class="line">004020E6   .  8985 4CFFFFFF mov dword ptr ss:[ebp-0xB4],eax</span><br><span class="line">004020EC   .  8D55 BC       lea edx,dword ptr ss:[ebp-0x44]</span><br><span class="line">004020EF   .  51            push ecx                                 ; /Step8 = 00120003</span><br><span class="line">004020F0   .  8D45 94       lea eax,dword ptr ss:[ebp-0x6C]          ; |</span><br><span class="line">004020F3   .  BB 02000000   mov ebx,0x2                              ; |</span><br><span class="line">004020F8   .  52            push edx                                 ; |/var18 = 00000001</span><br><span class="line">004020F9   .  50            push eax                                 ; ||retBuffer8 = NULL</span><br><span class="line">004020FA   .  899D 54FFFFFF mov dword ptr ss:[ebp-0xAC],ebx          ; ||</span><br><span class="line">00402100   .  899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx          ; ||</span><br><span class="line">00402106   .  FF15 18414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenVa&gt;; |\__vbaLenVar</span><br><span class="line">0040210C   .  8D8D 44FFFFFF lea ecx,dword ptr ss:[ebp-0xBC]          ; |</span><br><span class="line">00402112   .  50            push eax                                 ; |End8 = NULL</span><br><span class="line">00402113   .  8D95 E8FEFFFF lea edx,dword ptr ss:[ebp-0x118]         ; |</span><br><span class="line">00402119   .  51            push ecx                                 ; |Start8 = 00120003</span><br><span class="line">0040211A   .  8D85 F8FEFFFF lea eax,dword ptr ss:[ebp-0x108]         ; |</span><br><span class="line">00402120   .  52            push edx                                 ; |TMPend8 = 00000001</span><br><span class="line">00402121   .  8D4D DC       lea ecx,dword ptr ss:[ebp-0x24]          ; |</span><br><span class="line">00402124   .  50            push eax                                 ; |TMPstep8 = NULL</span><br><span class="line">00402125   .  51            push ecx                                 ; |Counter8 = 00120003</span><br><span class="line">00402126   .  FF15 20414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForInit</span><br><span class="line">0040212C   .  8B3D 04414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFr&gt;;  msvbvm50.__vbaFreeVarList</span><br><span class="line">00402132   &gt;  85C0          test eax,eax</span><br><span class="line">00402134   .  0F84 9C000000 je Andréna.004021D6</span><br><span class="line">0040213A   .  8D55 94       lea edx,dword ptr ss:[ebp-0x6C]</span><br><span class="line">0040213D   .  8D45 DC       lea eax,dword ptr ss:[ebp-0x24]</span><br><span class="line">00402140   .  52            push edx</span><br><span class="line">00402141   .  50            push eax</span><br><span class="line">00402142   .  C745 9C 01000&gt;mov dword ptr ss:[ebp-0x64],0x1</span><br><span class="line">00402149   .  895D 94       mov dword ptr ss:[ebp-0x6C],ebx</span><br><span class="line">0040214C   .  FF15 90414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaI4Var&gt;;  msvbvm50.__vbaI4Var</span><br><span class="line">00402152   .  8D4D BC       lea ecx,dword ptr ss:[ebp-0x44]          ; |</span><br><span class="line">00402155   .  50            push eax                                 ; |Start = 0x0</span><br><span class="line">00402156   .  8D55 84       lea edx,dword ptr ss:[ebp-0x7C]          ; |</span><br><span class="line">00402159   .  51            push ecx                                 ; |dString8 = 00120003</span><br><span class="line">0040215A   .  52            push edx                                 ; |RetBUFFER = 00000001</span><br><span class="line">0040215B   .  FF15 38414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcMidCha&gt;; \rtcMidCharVar</span><br><span class="line">00402161   .  8D45 84       lea eax,dword ptr ss:[ebp-0x7C]</span><br><span class="line">00402164   .  8D4D A8       lea ecx,dword ptr ss:[ebp-0x58]</span><br><span class="line">00402167   .  50            push eax                                 ; /String8 = NULL</span><br><span class="line">00402168   .  51            push ecx                                 ; |ARG2 = 00120003</span><br><span class="line">00402169   .  FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrVa&gt;; \__vbaStrVarVal</span><br><span class="line">0040216F   .  50            push eax                                 ; /String = NULL</span><br><span class="line">00402170   .  FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr</span><br><span class="line">00402176   .  66:8985 4CFFF&gt;mov word ptr ss:[ebp-0xB4],ax</span><br><span class="line">0040217D   .  8D55 CC       lea edx,dword ptr ss:[ebp-0x34]</span><br><span class="line">00402180   .  8D85 44FFFFFF lea eax,dword ptr ss:[ebp-0xBC]</span><br><span class="line">00402186   .  52            push edx                                 ; /var18 = 00000001</span><br><span class="line">00402187   .  8D8D 74FFFFFF lea ecx,dword ptr ss:[ebp-0x8C]          ; |</span><br><span class="line">0040218D   .  50            push eax                                 ; |var28 = NULL</span><br><span class="line">0040218E   .  51            push ecx                                 ; |saveto8 = 00120003</span><br><span class="line">0040218F   .  899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx          ; |</span><br><span class="line">00402195   .  FF15 94414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarAd&gt;; \__vbaVarAdd</span><br><span class="line">0040219B   .  8BD0          mov edx,eax</span><br><span class="line">0040219D   .  8D4D CC       lea ecx,dword ptr ss:[ebp-0x34]</span><br><span class="line">004021A0   .  FFD6          call esi                                 ;  msvbvm50.__vbaVarMove</span><br><span class="line">004021A2   .  8D4D A8       lea ecx,dword ptr ss:[ebp-0x58]</span><br><span class="line">004021A5   .  FF15 B8414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;;  msvbvm50.__vbaFreeStr</span><br><span class="line">004021AB   .  8D55 84       lea edx,dword ptr ss:[ebp-0x7C]</span><br><span class="line">004021AE   .  8D45 94       lea eax,dword ptr ss:[ebp-0x6C]</span><br><span class="line">004021B1   .  52            push edx</span><br><span class="line">004021B2   .  50            push eax</span><br><span class="line">004021B3   .  53            push ebx</span><br><span class="line">004021B4   .  FFD7          call edi                                 ;  msvbvm50.__vbaFreeVarList</span><br><span class="line">004021B6   .  83C4 0C       add esp,0xC</span><br><span class="line">004021B9   .  8D8D E8FEFFFF lea ecx,dword ptr ss:[ebp-0x118]</span><br><span class="line">004021BF   .  8D95 F8FEFFFF lea edx,dword ptr ss:[ebp-0x108]</span><br><span class="line">004021C5   .  8D45 DC       lea eax,dword ptr ss:[ebp-0x24]</span><br><span class="line">004021C8   .  51            push ecx                                 ; /TMPend8 = 00120003</span><br><span class="line">004021C9   .  52            push edx                                 ; |TMPstep8 = 00000001</span><br><span class="line">004021CA   .  50            push eax                                 ; |Counter8 = NULL</span><br><span class="line">004021CB   .  FF15 AC414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForNext</span><br><span class="line">004021D1   .^ E9 5CFFFFFF   jmp Andréna.00402132</span><br></pre></td></tr></table></figure><p>将相加的结果与 0x499602D2 相乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">004021D6   &gt; \8D4D CC       lea ecx,dword ptr ss:[ebp-0x34]</span><br><span class="line">004021D9   .  8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]</span><br><span class="line">004021DF   .  51            push ecx                                 ; /var18 = 0012F4AC</span><br><span class="line">004021E0   .  8D45 94       lea eax,dword ptr ss:[ebp-0x6C]          ; |</span><br><span class="line">004021E3   .  52            push edx                                 ; |var28 = 0012F474</span><br><span class="line">004021E4   .  50            push eax                                 ; |SaveTo8 = 0012F474</span><br><span class="line">004021E5   .  C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],0x499602D2   ; |</span><br><span class="line">004021EF   .  C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x3          ; |</span><br><span class="line">004021F9   .  FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarMu&gt;; \__vbaVarMul</span><br></pre></td></tr></table></figure><p>使用 “-” 替换相乘结果十进制表示形式的第4位和第9位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00402206   .  8B1D A0414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaMi&gt;;  msvbvm50.__vbaMidStmtVar</span><br><span class="line">0040220C   .  8D4D CC       lea ecx,dword ptr ss:[ebp-0x34]</span><br><span class="line">0040220F   .  51            push ecx</span><br><span class="line">00402210   .  6A 04         push 0x4</span><br><span class="line">00402212   .  8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]</span><br><span class="line">00402218   .  6A 01         push 0x1</span><br><span class="line">0040221A   .  52            push edx</span><br><span class="line">0040221B   .  C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;;  -</span><br><span class="line">00402225   .  C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x8</span><br><span class="line">0040222F   .  FFD3          call ebx                                 ;  msvbvm50.__vbaMidStmtVar; &lt;&amp;MSVBVM50.__vbaMidStmtVar&gt;</span><br><span class="line">00402231   .  8D45 CC       lea eax,dword ptr ss:[ebp-0x34]</span><br><span class="line">00402234   .  8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]</span><br><span class="line">0040223A   .  50            push eax</span><br><span class="line">0040223B   .  6A 09         push 0x9</span><br><span class="line">0040223D   .  6A 01         push 0x1</span><br><span class="line">0040223F   .  51            push ecx</span><br><span class="line">00402240   .  C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;;  -</span><br><span class="line">0040224A   .  C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x8</span><br><span class="line">00402254   .  FFD3          call ebx                                 ;  msvbvm50.__vbaMidStmtVar</span><br></pre></td></tr></table></figure><p>例如，注册名为“test”，计算流程为：</p><ol><li>注册名每一位相加，得到 0x1C0；</li><li>0x1C0 * 0x499602D2 = 0x‭80C684EF80‬ = ‭553086414720‬</li><li>将 ‭553086414720‬ 中的第4位和第9位数字替换为 “-”；</li><li>得到注册码为 ‭553-8641-720。</li></ol><p>进行验证。</p><p><img src="注册成功.png" alt="注册成功"></p><h2 id="0x3-参考"><a href="#0x3-参考" class="headerlink" title="0x3 参考"></a>0x3 参考</h2><ul><li><a href="https://www.52pojie.cn/thread-265789-1-1.html" target="_blank" rel="noopener">[反汇编练习] 160个CrackMe之009 (出处: 吾爱破解论坛)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;160个新手练习CrackMe，第9个。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="CrackMe" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/CrackMe/"/>
    
    
  </entry>
  
  <entry>
    <title>CE教程程序通关</title>
    <link href="http://yoursite.com/2019/04/03/Reverse/Software/CE%E6%95%99%E7%A8%8B%E7%A8%8B%E5%BA%8F%E9%80%9A%E5%85%B3/"/>
    <id>http://yoursite.com/2019/04/03/Reverse/Software/CE教程程序通关/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-04-03T03:03:35.930Z</updated>
    
    <content type="html"><![CDATA[<p>CheatEngine作为一款强大的内存修改工具，自带了一套使用教程，帮助新人可以快速上手使用。</p><p>教程一共分为9关，每一关都采用不同的搜索类型，帮助使用者熟悉CE的使用方法。</p><a id="more"></a><h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>第一关是欢迎关卡，说明如何使用CE加载目标进程。</p><ol><li>打开CE；</li><li>点击“Open Process“按钮；</li><li>从进程列表中选择类似”00001F98-Tutorial-x86_64.exe“的Tutorial-x86_64进程；</li><li>发现目标进程后，点击”Open“按钮，即可附加到目标进程。</li></ol><p><img src="第一关.png" alt="第一关"></p><p>完成进程加载后，点击”Next“按钮进入下一关。</p><h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>第二关为精确值搜索。目标为将健康值修改为1000。</p><p><img src="第二关.png" alt="第二关"></p><p>可以看到健康值，即Health值为100，点击一下”Hit me“，健康值减少随机数值。</p><p>首先”Scan Type“（扫描类型）选择”Exact Value“（精确值），”Value Type”（值类型）选择”4 Bytes”。</p><p>然后在Value框中输入100，点击”First Scan“（首次扫描），进行第一次扫描。</p><p><img src="第二关-第一次搜索结果.png" alt="第一次搜索结果"></p><p>搜索结果出现了许多，无法确定哪个是目标地址。点击”Hit me“，健康值减少，输入新的健康值，点击”Next Scan“（再次扫描），进行第二次扫描。</p><p>重复上面步骤，直到结果惟一，即是目标地址。</p><p><img src="第二关-最终结果.png" alt="最终结果"></p><p>双击加入地址列表。</p><p><img src="第二关-加入地址列表.png" alt="加入地址列表"></p><p>双击地址最后一列的“Value”，将值修改为1000。“Next”按钮变为可点击，进入下一关。</p><h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p>第三关为未知初始值。目标为将健康值修改为5000。</p><p><img src="第三关.png" alt="第三关"></p><p>可以看到无法确定健康值的初始值，只有一个满格生命条。点击“Hit me”会显示减少的健康值，而且生命条也会减少。根据提示，可以知道健康值位于0-500之间。</p><ol><li>点击“New Scan”，开启新的扫描；</li><li>“Scan Type”选择“Unknown Initial value”（未知的初始化值）；</li><li>“Value Type”选择“4 Butes”；</li><li>点击“First Scan”，进行第一次扫描。</li></ol><p><img src="第三关-第一次扫描.png" alt="第一次扫描"></p><ol start="5"><li><p>点击“Hit me”，减少健康值；</p></li><li><p>“Scan Type”选择“Decreased value”;</p></li><li>点击”Next Scan“，进行第二次扫描；</li><li>重复第二次扫描，直到结果数量不再变化；</li></ol><p><img src="第三关-最终结果.png" alt="最终结果"></p><ol start="9"><li>选择符合健康值范围的地址，加入地址列表。</li><li>将值修改为5000。</li></ol><p>点击”Next“，进入下一关。</p><h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p>第四关为浮点指针。目标为将健康值和弹药修改为5000或更高。</p><p><img src="第四关.png" alt="第四关"></p><p>首先修改健康值。</p><ol><li>”Scan Type“选择”Exact Value“；</li><li>”Value Type“选择”float“；</li><li>Value输入框输入100，进行第一次搜索。</li><li>点击”Hit me“，减少健康值；</li><li>修改搜索数值，进行第二次搜索；</li><li>重复第二次搜索步骤，直到结果惟一；</li><li>结果加入地址列表，修改值为5000。</li></ol><p>然后修改弹药值。</p><ol><li>”Scan Type“选择”Exact Type“；</li><li>”Value Type“选择”double“；</li><li>输入100，第一次搜索；</li><li>如果结果有多个，则点击”Fire“，减少弹药值，进行再次搜索；</li><li>当结果惟一时，加入地址列表，修改值为5000。</li></ol><p>健康值和弹药值都搜索完毕后，进入下一关。</p><h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p>第五关是代码查找。目的是查找修改值的汇编指令，并将其替换为nop指令。</p><p><img src="第五关.png" alt="第五关"></p><p>首先确定目标值的地址。</p><p>确定后，加入地址列表，右击选择”找出什么写入该地址“，弹出空白指令窗口。</p><p>再次点击”Change value“按钮，空白指令窗口出现一条指令，该指令就是修改目标值的指令。</p><p>单击该指令，将其替换为nop指令。</p><p>点击”Stop“按钮，停止调试器，教程正常运行。</p><p>点击”Change value“后，目标值不会变化，进入下一关。</p><h3 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h3><p>第六关是指针。目标为找到目标值基址并冻结该值。</p><p><img src="第六关.png" alt="第六关"></p><p>首先确定目标值的当前地址，加入地址列表。</p><p>右击该地址，找出什么访问了该地址。</p><p><img src="第六关-找出访问指令.png" alt="找出访问指令"></p><p>双击任意一条指令，可以看到更多的信息。基地址为 0x00601630。</p><p>点击主界面上”Add Address Manually“，手动设置指针。</p><p><img src="第六关-设置指针.png" alt="设置指针"></p><p>点击指针地址前的方框，锁定其值。点击教程中的”Change pointer“，改变指针。</p><p>进入下一关。</p><h3 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h3><p>第七关是代码注入。目标是通过代码注入是”Hit me“按钮增加2健康值。</p><p><img src="第七关.png" alt="第七关"></p><p>首先定位健康值的地址，加入地址列表。</p><p>然后找出修改目标值的指令。</p><p>查看该指令处的反汇编窗口，打开”Auto assemble“（Ctrl + A）窗口。</p><p>生成代码注册模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">alloc(newmem,2048)</span><br><span class="line">label(returnhere)</span><br><span class="line">label(originalcode)</span><br><span class="line">label(exit)</span><br><span class="line"></span><br><span class="line">newmem: //this is allocated memory, you have read,write,execute access</span><br><span class="line">//place your code here</span><br><span class="line"></span><br><span class="line">originalcode:</span><br><span class="line">sub dword ptr [ebx+00000478],01</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">jmp returnhere</span><br><span class="line"></span><br><span class="line">&quot;Tutorial-i386.exe&quot;+2585D:</span><br><span class="line">jmp newmem</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">returnhere:</span><br></pre></td></tr></table></figure><p>在<code>//place your code here</code>下输入想要执行的代码<code>add dword ptr [ebx+00000478],03</code>。</p><p>点击”Execute“，注入代码。</p><p><img src="第七关-注入后的代码.png" alt="注入后的代码"></p><p>点击”Hit me“按钮，健康值增加2，进入下一关。</p><h3 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h3><p>第八关是多级指针。目标是找到4级指针的基址并将健康值锁定为5000。</p><p><img src="第八关.png" alt="第八关"></p><p>首先找到健康值地址，加入地址列表。</p><p>找出访问该地址的指令，发现<code>[esi + 18]</code>，这是第一级指针esi = 0x01690370，偏移为 0x18。</p><p>主界面搜索第一级指针存储地址，加入地址列表。</p><p>找出访问该地址的指令，发现<code>[esi]</code>，第二级指针esi = 0x01723150，偏移为 0x0。</p><p>主界面搜索第二级指针存储地址，加入地址列表。</p><p>找出访问该地址的指令，发现<code>[esi + 14]</code>，第三级指针esi = 0x0166F060，偏移为 0x14。</p><p>主界面搜索第三级指针存储地址，加入地址列表。</p><p>找出访问该地址的指令，发现<code>[esi + 0C]</code>，第四纪指针esi = 0x01716000，偏移为 0xC。</p><p>主界面搜索第四级指针存储地址，加入地址列表。</p><p>找出访问该地址的指令，发现基址 0x00601660。</p><p>设置指针地址。</p><p><img src="第八关-四级指针.png" alt="四级指针"></p><p>修改健康值为5000，锁定指针地址，点击教程界面”Change pointer“，进入下一关。</p><h3 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h3><p>第九关是共享代码。目的是处理其他相同类型对象共同使用的代码。</p><p><img src="第九关.png" alt="第九关"></p><p>找到每个玩家健康值的地址，加入地址列表。</p><p>然后找出修改健康值的指令，共用指令<code>mov [ebx + 0x4],eax</code>。</p><p>查看四个玩家的ebx处的内存。</p><p>Player 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">019647C8  78 E5 5A 00 00 00 C0 42 09 27 00 00 F3 E9 46 00  x錤...繠.&apos;..箝F.</span><br><span class="line">019647D8  01 00 00 00 04 44 61 76 65 00 00 00 00 00 00 00  ...Dave.......</span><br></pre></td></tr></table></figure><p>Player 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0197CB68  78 E5 5A 00 00 00 BC 42 38 01 00 00 01 03 48 00  x錤...糂8..H.</span><br><span class="line">0197CB78  01 00 00 00 04 45 72 69 63 00 00 00 00 00 00 00  ...Eric.......</span><br></pre></td></tr></table></figure><p>Player 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">019A47D0  78 E5 5A 00 00 00 F9 43 4C 25 00 00 F8 83 0E 00  x錤...鵆L%..鴥.</span><br><span class="line">019A47E0  02 00 00 00 03 48 41 4C 00 00 00 00 00 00 00 00  ...HAL........</span><br></pre></td></tr></table></figure><p>Player 4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">019BCB70  78 E5 5A 00 00 00 F9 43 09 1A 00 00 90 B1 1C 00  x錤...鵆...惐.</span><br><span class="line">019BCB80  02 00 00 00 04 4B 49 54 54 00 00 00 00 00 00 00  ...KITT.......</span><br></pre></td></tr></table></figure><p>分析可知，第5-8字节是玩家的健康值（小端序存储，以42000000为0，以健康值的2倍保存），第17个字节为队伍编号，第21字节为玩家名长度，第22字节开始是玩家名。</p><p>可以编写通过队伍编号进行区分的注入代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">alloc(newmem,2048)</span><br><span class="line">label(returnhere)</span><br><span class="line">label(originalcode)</span><br><span class="line">label(exit)</span><br><span class="line"></span><br><span class="line">newmem: //this is allocated memory, you have read,write,execute access</span><br><span class="line">//place your code here</span><br><span class="line">cmp byte ptr [ebx+10],0x01</span><br><span class="line">jne originalcode</span><br><span class="line">mov eax,[ebx+04]</span><br><span class="line"></span><br><span class="line">originalcode:</span><br><span class="line">mov [ebx+04],eax</span><br><span class="line">fldz </span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">jmp returnhere</span><br><span class="line"></span><br><span class="line">&quot;Tutorial-i386.exe&quot;+26857:</span><br><span class="line">jmp newmem</span><br><span class="line">returnhere:</span><br><span class="line">alloc(newmem,2048)</span><br><span class="line">label(returnhere)</span><br><span class="line">label(originalcode)</span><br><span class="line">label(exit)</span><br><span class="line"></span><br><span class="line">newmem: //this is allocated memory, you have read,write,execute access</span><br><span class="line">//place your code here</span><br><span class="line">cmp byte ptr [ebx+07],0x42</span><br><span class="line">jne newmem2</span><br><span class="line">mov eax,[ebx+04]</span><br><span class="line">jmp originalcode</span><br><span class="line"></span><br><span class="line">newmem2:</span><br><span class="line">mov eax,0x43000000</span><br><span class="line"></span><br><span class="line">originalcode:</span><br><span class="line">mov [ebx+04],eax</span><br><span class="line">fldz </span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">jmp returnhere</span><br><span class="line"></span><br><span class="line">&quot;Tutorial-i386.exe&quot;+26857:</span><br><span class="line">jmp newmem</span><br><span class="line">returnhere:</span><br></pre></td></tr></table></figure><p>注入代码后，点击”Restart game and autoplay“，完成关卡。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CheatEngine作为一款强大的内存修改工具，自带了一套使用教程，帮助新人可以快速上手使用。&lt;/p&gt;
&lt;p&gt;教程一共分为9关，每一关都采用不同的搜索类型，帮助使用者熟悉CE的使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="逆向分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="软件分析" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
</feed>
