<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[160个CrackMe之004]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B004%2F</url>
    <content type="text"><![CDATA[160个CrackMe，第4个。 0x1 环境 系统：Windows XP SP3 软件：CKme.exe 工具：PEiD v0.95、吾爱破解专用版OllyDbg、DeDeDark v3.50.04 0x2 分析运行程序，需要用户名和注册码，验证成功则会显示“朱茵”小姐姐的照片。 值得注意的是，该程序没有确定按钮，说明应该是每输入一次就读取输入框中的内容。而且，注册失败也不会出现失败提示，所以无法从失败提示入手。 首先PEiD进行查壳，无壳，Borland Delphi 编写。 既然是Delphi编写，放入DeDe反编译看下，发现五个过程事件函数。 根据事件函数的名称可以猜测分别是什么功能。首先应该分析下”chkcode”函数。 将程序载入OD，跳转到该函数地址。在函数开始下断，输入用户名和注册码，程序断下。 分析chkcode函数，主要分为两个部分。 计算正确的注册码 12345678910111213141500457C66 |. 8BB3 F8020000 mov esi,dword ptr ds:[ebx+0x2F8] ; 获取用户名长度00457C6C |. 83C6 05 add esi,0x5 ; 长度加0x500457C6F |. FFB3 10030000 push dword ptr ds:[ebx+0x310] ; 压栈&quot;黑头Sun Bird&quot;00457C75 |. 8D55 F8 lea edx,[local.2]00457C78 |. 8BC6 mov eax,esi00457C7A |. E8 85FEFAFF call CKme.00407B04 ; 将数字转为Unicode字符串00457C7F |. FF75 F8 push [local.2] ; 压栈加0x5后的用户名长度00457C82 |. FFB3 14030000 push dword ptr ds:[ebx+0x314] ; 压栈&quot;dseloffc-012-OK&quot;00457C88 |. 8D55 F4 lea edx,[local.3]00457C8B |. 8B83 D4020000 mov eax,dword ptr ds:[ebx+0x2D4]00457C91 |. E8 B2B6FCFF call CKme.00423348 ; 获取用户名00457C96 |. FF75 F4 push [local.3] ; 压栈用户名00457C99 |. 8D83 18030000 lea eax,dword ptr ds:[ebx+0x318]00457C9F |. BA 04000000 mov edx,0x400457CA4 |. E8 93BFFAFF call CKme.00403C3C ; 拼接之前压栈的字符串 比较注册码 12345678900457D1E |. 8D55 E0 lea edx,[local.8]00457D21 |. 8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8]00457D27 |. E8 1CB6FCFF call CKme.00423348 ; 获取输入的注册码00457D2C |. 8B45 E0 mov eax,[local.8]00457D2F |. 8B93 18030000 mov edx,dword ptr ds:[ebx+0x318]00457D35 |. E8 52BFFAFF call CKme.00403C8C ; 比较注册码00457D3A 75 0A jnz short CKme.00457D46 ; 跳转为失败，不跳转为成功00457D3C |. C783 0C030000&gt;mov dword ptr ds:[ebx+0x30C],0x3E ; 设置注册标志00457D46 |&gt; 8B83 0C030000 mov eax,dword ptr ds:[ebx+0x30C] 中间有一段用于混淆视听的代码，可以忽略。 该程序的注册码很简单： 用户名长度 + 0x5，并转为Unicode字符串。 将“黑头Sun Bird”、“&lt;第一步字符串&gt;”、“dseloffc-012-OK”和用户名依次连接。 如，用户名为“test”，则注册码为“黑头Sun Bird9dseloffc-012-OKtest”。 找到注册码之后，并不能直接显示“朱茵”小姐姐的照片。 在Panel1Click函数下断，可以看到注册成功的字符串。而想要显示注册成功，则注册标志必须为 0x85，但是在验证函数中，该标志被设置为 0x3E，那么一定有地方进行了修改。 在OD中搜索所有包含常量 0x85 的指令。 找到修改代码，该代码位于 0x00457E7C 的函数中，而该函数是”Panel1DblClick”函数。 所以，在输入正确的用户名和注册码后，需要在图片框先双击，再单击，才最终注册成功。 0x3 参考 [反汇编练习] 160个CrackMe之004（CKme）详细分析 (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之002]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B002%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第二个。 0x1 环境 系统：Windows XP SP3 软件：Afkayas.1.exe 工具：PEiD v0.95、吾爱破解专用版OllyDbg 0x2 分析运行程序，需要输入正确的用户名和密码。 PEiD查壳，无壳，Microsoft Visual Basic 编写。 输入任意用户名和注册码，得到失败提示。 载入OD，搜索字符串，确定错误提示位置。 逆向分析数据流，找到关键跳转。 123456700402579 . 66:85F6 test si,si0040257C . 8945 94 mov dword ptr ss:[ebp-0x6C],eax0040257F . 894D AC mov dword ptr ss:[ebp-0x54],ecx00402582 . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax00402585 . 894D BC mov dword ptr ss:[ebp-0x44],ecx00402588 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax0040258B . 74 58 je short Afkayas_.004025E5 ; 跳转为注册失败，不跳转为注册成功 得益于OD的强大，继续向上发现比较函数。 1200402532 . 50 push eax00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;; msvbvm50.__vbaStrCmp 在此处下断，F9运行到这里，从栈中得到正确的验证码和输入的假码。 120012F408 0015E91C UNICODE &quot;AKA-390240&quot;0012F40C 0015E8F4 UNICODE &quot;123456&quot; 上方挨着字符串拼接函数，将“AKA-”与正确的序列号连接起来。 123456700402510 &gt; \8B45 E8 mov eax,dword ptr ss:[ebp-0x18]00402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C]00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaSt&gt;; msvbvm50.__vbaStrCat0040251C . 50 push eax0040251D . 68 701B4000 push Afkayas_.00401B70 ; AKA-00402522 . 51 push ecx ; /String = &quot;3&quot;00402523 . FFD7 call edi ; \__vbaStrCat 继续分析，找到序列号生成算法。 1234567891011121314151600402409 &gt; \8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]0040240F . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C]00402412 . 50 push eax ; /String = NULL00402413 . 8B1A mov ebx,dword ptr ds:[edx] ; |00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \__vbaLenBstr0040241B . 8BF8 mov edi,eax0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; 用户名长度 * 0x17CFB00402426 . 51 push ecx ; /String = &quot;?&quot;00402427 . 0F80 91020000 jo Afkayas_.004026BE ; |0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx,ax00402436 . 03FA add edi,edx ; 上一次乘法结果 + 用户名第一位的ASCII码00402438 . 0F80 80020000 jo Afkayas_.004026BE0040243E . 57 push edi0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; 将十六进制转为十进制表示 生成流程为： 计算用户名长度。 长度与0x17CFB相乘。 第二步结果与用户名第一个字符的ASCII码相加。 将第三步结果转为十进制表示。 将十进制表示转为字符串类型。 例如用户名为test，注册码为AKA-390240，输入程序，注册成功。 分析完毕！ 0x3 参考 [反汇编练习] 160个CrackMe之002 (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之008]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B008%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第8个。 0x1 环境 系统：Windows XP SP3 软件：Andrénalin.1.exe 工具：PEiD v0.95、吾爱破解专用版OllyDbg 0x2 分析运行程序，注册码注册。 PEiD查壳，无壳，Microsoft Visual Basic 编写。 输入任意注册码，弹出注册失败提示。 载入OD，确定失败字符串的位置，定位注册函数。 123456789101112131400401D73 . 51 push ecx ; 假码00401D74 . 68 541A4000 push Andréna.00401A54 ; SynTaX 2oo100401D79 . FF15 08314000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCm&gt;; msvbvm50.__vbaStrCmp00401D7F . 8BF8 mov edi,eax00401D81 . 8D4D D8 lea ecx,dword ptr ss:[ebp-0x28]00401D84 . F7DF neg edi00401D86 . 1BFF sbb edi,edi00401D88 . 47 inc edi00401D89 . F7DF neg edi00401D8B . FF15 5C314000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStr00401D91 . 8D4D D4 lea ecx,dword ptr ss:[ebp-0x2C]00401D94 . FF15 60314000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeO&gt;; msvbvm50.__vbaFreeObj00401D9A . 66:3BFE cmp di,si00401D9D . 0F84 A0000000 je Andréna.00401E43 ; 跳转为注册失败，不跳转为注册成功 找到__vbaStrCmp字符串比较函数，下断后运行，可以在栈中看到比较的字符串。 120012F3FC 00401A54 UNICODE &quot;SynTaX 2oo1&quot;0012F400 00161F1C UNICODE &quot;123456&quot; 输入的假码为“123456”，所以真码为“SynTaX 2oo1”。 进行验证。 0x3 参考 初练160个CrakeMe程序之008 (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之010]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B010%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第10个。 0x1 环境 系统：Windows XP SP3 软件：Andrénalin.3 工具：PEiD v0.95、吾爱破解专用版OllyDbg 0x2 分析运行程序，注册码验证。 PEiD查壳，无壳，Microsoft Visual Basic 编写。 输入任意注册码，提示注册失败。 载入OD，确定失败字符串，定位关键跳转。 1200402050 . 66:85C0 test ax,ax00402053 . 0F84 C0000000 je Andréna.00402119 ; 跳转为注册失败，不跳转为注册成功 发现比较函数，加密后的真码为kXy^rO|*yXo*m\kMuOn*+。 12345670040202B &gt; \8D45 CC lea eax,dword ptr ss:[ebp-0x34]0040202E . 8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]00402034 . 50 push eax ; /var18 = 0012F4AC00402035 . 51 push ecx ; |var28 = 0012F43400402036 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; |kXy^rO|*yXo*m\kMuOn*+00402040 . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x8008 ; |0040204A . FF15 40414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarTs&gt;; \__vbaVarTstEq 向上分析，发现加密循环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828300401F05 . B9 02000000 mov ecx,0x200401F0A . B8 01000000 mov eax,0x100401F0F . 898D 54FFFFFF mov dword ptr ss:[ebp-0xAC],ecx00401F15 . 898D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ecx00401F1B . 8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]00401F21 . 8985 5CFFFFFF mov dword ptr ss:[ebp-0xA4],eax00401F27 . 8985 4CFFFFFF mov dword ptr ss:[ebp-0xB4],eax00401F2D . 8D55 BC lea edx,dword ptr ss:[ebp-0x44]00401F30 . 51 push ecx ; /Step8 = 0012F43400401F31 . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C] ; |00401F34 . 52 push edx ; |/var18 = 0000000100401F35 . 50 push eax ; ||retBuffer8 = 0012F4AC00401F36 . FF15 14414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenVa&gt;; |\__vbaLenVar00401F3C . 8D8D 44FFFFFF lea ecx,dword ptr ss:[ebp-0xBC] ; |00401F42 . 50 push eax ; |End8 = 0012F4AC00401F43 . 8D95 ECFEFFFF lea edx,dword ptr ss:[ebp-0x114] ; |00401F49 . 51 push ecx ; |Start8 = 0012F43400401F4A . 8D85 FCFEFFFF lea eax,dword ptr ss:[ebp-0x104] ; |00401F50 . 52 push edx ; |TMPend8 = 0000000100401F51 . 8D4D DC lea ecx,dword ptr ss:[ebp-0x24] ; |00401F54 . 50 push eax ; |TMPstep8 = 0012F4AC00401F55 . 51 push ecx ; |Counter8 = 0012F43400401F56 . FF15 1C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForInit00401F5C . 8B1D 68414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVa&gt;; msvbvm50.__vbaVarCat00401F62 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFr&gt;; msvbvm50.__vbaFreeVarList00401F68 &gt; 85C0 test eax,eax00401F6A . 0F84 BB000000 je Andréna.0040202B00401F70 . 8D55 94 lea edx,dword ptr ss:[ebp-0x6C]00401F73 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]00401F76 . 52 push edx00401F77 . 50 push eax00401F78 . C745 9C 01000&gt;mov dword ptr ss:[ebp-0x64],0x100401F7F . C745 94 02000&gt;mov dword ptr ss:[ebp-0x6C],0x200401F86 . FF15 90414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaI4Var&gt;; msvbvm50.__vbaI4Var00401F8C . 8D4D BC lea ecx,dword ptr ss:[ebp-0x44] ; |00401F8F . 50 push eax ; |Start = 0x12F4AC00401F90 . 8D55 84 lea edx,dword ptr ss:[ebp-0x7C] ; |00401F93 . 51 push ecx ; |dString8 = 0012F43400401F94 . 52 push edx ; |RetBUFFER = 0000000100401F95 . FF15 34414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcMidCha&gt;; \rtcMidCharVar00401F9B . 8D45 84 lea eax,dword ptr ss:[ebp-0x7C]00401F9E . 8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]00401FA1 . 50 push eax ; /String8 = 0012F4AC00401FA2 . 51 push ecx ; |ARG2 = 0012F43400401FA3 . FF15 64414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrVa&gt;; \__vbaStrVarVal00401FA9 . 50 push eax ; /String = &quot;&quot;00401FAA . FF15 08414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr00401FB0 . 66:05 0A00 add ax,0xA00401FB4 . 0F80 B0020000 jo Andréna.0040226A00401FBA . 0FBFD0 movsx edx,ax00401FBD . 52 push edx00401FBE . FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcBstrFr&gt;; msvbvm50.rtcBstrFromAnsi00401FC4 . 8985 7CFFFFFF mov dword ptr ss:[ebp-0x84],eax00401FCA . 8D45 CC lea eax,dword ptr ss:[ebp-0x34]00401FCD . 8D8D 74FFFFFF lea ecx,dword ptr ss:[ebp-0x8C]00401FD3 . 50 push eax00401FD4 . 8D95 64FFFFFF lea edx,dword ptr ss:[ebp-0x9C]00401FDA . 51 push ecx00401FDB . 52 push edx00401FDC . C785 74FFFFFF&gt;mov dword ptr ss:[ebp-0x8C],0x800401FE6 . FFD3 call ebx ; msvbvm50.__vbaVarCat00401FE8 . 8BD0 mov edx,eax00401FEA . 8D4D CC lea ecx,dword ptr ss:[ebp-0x34]00401FED . FFD6 call esi ; msvbvm50.__vbaVarMove00401FEF . 8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]00401FF2 . FF15 B0414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStr00401FF8 . 8D85 74FFFFFF lea eax,dword ptr ss:[ebp-0x8C]00401FFE . 8D4D 84 lea ecx,dword ptr ss:[ebp-0x7C]00402001 . 50 push eax00402002 . 8D55 94 lea edx,dword ptr ss:[ebp-0x6C]00402005 . 51 push ecx00402006 . 52 push edx00402007 . 6A 03 push 0x300402009 . FFD7 call edi ; msvbvm50.__vbaFreeVarList0040200B . 83C4 10 add esp,0x100040200E . 8D85 ECFEFFFF lea eax,dword ptr ss:[ebp-0x114]00402014 . 8D8D FCFEFFFF lea ecx,dword ptr ss:[ebp-0x104]0040201A . 8D55 DC lea edx,dword ptr ss:[ebp-0x24]0040201D . 50 push eax ; /TMPend8 = 0012F4AC0040201E . 51 push ecx ; |TMPstep8 = 0012F4340040201F . 52 push edx ; |Counter8 = 0000000100402020 . FF15 A4414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForNext00402026 .^ E9 3DFFFFFF jmp Andréna.00401F68 实际很简单，就是将输入注册码的每一位加上 0xA，再与正确的加密验证码比较。 通过反向计算，可以得到真正的注册码。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;void main()&#123; char code[] = &quot;kXy^rO|*yXo*m\\kMuOn*+&quot;; int i; for(i = 0; i &lt; strlen(code); i++) &#123; code[i] = code[i] - 0xA; &#125; printf(&quot;%s\n&quot;, code);&#125; 结果为：aNoThEr oNe cRaCkEd !。 进行验证。 0x3 参考 [反汇编练习] 160个CrackMe之010 (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[植物大战僵尸之任意阳光修改]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FGame%2F%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E4%BB%BB%E6%84%8F%E9%98%B3%E5%85%89%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[植物大战僵尸是一款很经典的单机游戏了，作为很早之前的一款游戏，很适合作为学习分析游戏外挂的入门级练习。因此，在练习的同时，写下分析过程，作为学习的记录。 准备 系统：Windows 10 专业版 64位 软件：植物大战僵尸中文版 工具：CheatEngine v6.8.2 目标：任意阳光修改 分析游戏运行时所需要的数据，一般都会放在内存中，以便随时获取，特别时对于一些经常修改的数值。 植物大战僵尸中的阳关值就是经常变化的数值，所以，想要对其进行修改，首先要在内存中找到它的位置。 使用CE附加到游戏进程上，准备对其内存进行搜索。 查看当前游戏中阳光值。 在CE中进行第一次搜索。 搜索结果有773个，太多了。进入游戏改变阳光值，进行第二次搜索。 结果剩了一个，那么这个就是要找的内存地址了。有时不会这么快出现唯一地址的，只需要多改变几次数值，进行搜索即可。 双击结果中的地址添加到下方的地址列表中，修改该地址数值，查看游戏中的阳光值，验证该地址。 阳光值修改成功，证明该地址正确。 不过，这个内存地址只是临时的，是游戏中用来临时保存当前游戏局中阳光值的，重新开始关卡或者开始别的关卡，保存阳光值的地址就会发生变化。 但是，无论怎么变化，游戏总能准确的找到这个保存阳光的地址，那么游戏中一定存在一个基址，通过这个基地址，作为地址指针，经过一系列偏移，就可以确定每句游戏用来保存阳光值的地址了。 现在已经确定了当前游戏中保存阳光值的地址，那么通过查找有哪些地址访问了该地址，进而反向追溯，就可以找到阳光的基址了。 使用CE查找哪些地址访问了当前阳光保存地址。 可以看到有两个地址访问了当前阳光值地址，而这两个地址全都采用了 0x5560 的偏移量，所以寄存器的值就是上一级地址指针的中的值，为 0x1BC86BC8。 使用CE搜索哪些内存中保存着该指针。 结果有很多，可以进行依次排除，不过，一般都是与其他结果相差比较大的就是我们要找的，这个是因为啥，我暂时没想明白。 这里就是结果中的第一个结果，加入地址列表。 查找访问哪些地址访问了该内存地址。 可以明显看出，地址偏移为 0x768，寄存器中的值为 0x02809C80。 与上面一样，进行搜索。排除后有两个地址不确定，这两个地址都有一个固定地址访问，而且不同。 分别是 0x006A9EC0 和 0x006A9F38。 不过，既然是基地址，那么都有可能是阳光值的基址，添加指针地址，重新开始游戏，确定基址。 最后证明，这两个都是游戏的基址，额！ 可能是因为游戏版本的问题吧，两个基址都可以使用。 最后整理分析出的数据。 阳光的基址为：0x006A9EC0 和 0x006A9F38。 偏移依次为：0x0、0x768 和 0x5560。 阳光地址计算为： 123第二级指针 = [006A9EC0]第一级指针 = [第二级指针 + 0x768]阳光值地址 = [第一级指针 + 0x5560] 依据这些地址与偏移，就可编写出任意修改阳光的程序了。]]></content>
      <categories>
        <category>逆向分析</category>
        <category>游戏分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[植物大战僵尸之无限阳光]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FGame%2F%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E6%97%A0%E9%99%90%E9%98%B3%E5%85%89%2F</url>
    <content type="text"><![CDATA[植物大战僵尸系列分析记录，第二篇。 准备 系统：Windows 10 专业版 64位 软件：植物大战僵尸中文版 工具：CheatEngine v6.8.2 目标：无限阳光 分析实现无限阳光的功能，只需要满足： 阳光值设置为最大值9999。 阳光值不会减少。 第一个条件在上一篇记录中已经实现，第二个条件需要确定阳光减少指令。 任意开始一局游戏，利用CE定位当前阳光值的地址。 在该地址上右键选择“Find out what writes to this address”，确定哪些地址对该阳光值进行了修改。 从指令上可以看出，第一条指令是增加阳光值的指令，第二条是修改阳光值的指令。 实现目标的方法有很多，我就任意选择了一种。 双击第二条指令，可以看到详细信息。 在 0x0041BA74 处是减法指令，可以猜测出esi中存储的是当前阳光值，而ebx存储的是需要减去的阳光值。 比较直接的方式就是将该指令nop掉，也可以将ebx改为 0x0，只要不减少阳光值即可。]]></content>
      <categories>
        <category>逆向分析</category>
        <category>游戏分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[植物大战僵尸之无限种植]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FGame%2F%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E6%97%A0%E9%99%90%E7%A7%8D%E6%A4%8D%2F</url>
    <content type="text"><![CDATA[植物大战僵尸分析练习，第三篇。 本次想要实现的功能是无限种植，即一块方格上可以无限种植植物。 准备 系统：Windows 10 x64 专业版 软件：植物大战僵尸中文版 工具：CheatEngine v6.8.2、吾爱破解专用版OllyDbg 目标：无限种植 分析整理思路，想要实现目标，需要寻找的有： 植物种下代码。 该方块是否可以种植。 以阳光值为切入点，定位当前阳光值地址。 找出修改该处阳光值的指令。 我选择第一条mov指令进行分析。 记录该指令地址，使用OD附加游戏进程（此时需要退出CE）。 跳转到该地址，该指令所在函数功能很简单，就是修改阳光值。 1234567891011120041BA60 56 push esi0041BA61 8BB7 60550000 mov esi,dword ptr ds:[edi+0x5560]0041BA67 8BD7 mov edx,edi0041BA69 E8 12FFFFFF call Plants_v.0041B9800041BA6E 03C6 add eax,esi0041BA70 3BD8 cmp ebx,eax0041BA72 7F 0C jg short Plants_v.0041BA800041BA74 2BF3 sub esi,ebx ; 减去所需的阳光值0041BA76 89B7 60550000 mov dword ptr ds:[edi+0x5560],esi ; 减少当前阳光值指令0041BA7C B0 01 mov al,0x10041BA7E 5E pop esi0041BA7F C3 retn 下断，运行到上一层函数，对周围进行简单分析，可以猜测这里是植物种下代码逻辑。 1234567891011121314151617180041083C 8B85 8C000000 mov eax,dword ptr ss:[ebp+0x8C]00410842 80B8 14080000 0&gt;cmp byte ptr ds:[eax+0x814],0x000410849 75 33 jnz short Plants_v.0041087E0041084B 8BB5 38010000 mov esi,dword ptr ss:[ebp+0x138] ; 猜测-esi的值为植物栏对象的地址00410851 837E 30 01 cmp dword ptr ds:[esi+0x30],0x100410855 75 27 jnz short Plants_v.0041087E00410857 8BC5 mov eax,ebp00410859 E8 F2B50000 call Plants_v.0041BE500041085E 84C0 test al,al00410860 75 1C jnz short Plants_v.0041087E00410862 8B56 2C mov edx,dword ptr ds:[esi+0x2C]00410865 8B46 28 mov eax,dword ptr ds:[esi+0x28] ; 取得植物位置指令00410868 8BFD mov edi,ebp0041086A E8 71D20000 call Plants_v.0041DAE0 ; 0x0041DAE0-获取当前需要减少的阳光值0041086F 8BD8 mov ebx,eax00410871 E8 EAB10000 call Plants_v.0041BA60 ; 0x0041BA60-减少当前阳光值00410876 84C0 test al,al00410878 0F84 D4060000 je Plants_v.00410F52 找到的第一个小目标，现在确定种植判断。 运行到函数返回，可以找到函数调用位置。 12345678004121FE 8B4D 0C mov ecx,dword ptr ss:[ebp+0xC]00412201 8B55 08 mov edx,dword ptr ss:[ebp+0x8]00412204 51 push ecx00412205 52 push edx00412206 57 push edi00412207 8BCB mov ecx,ebx00412209 E8 22DBFFFF call Plants_v.0040FD30 ; 0x0040FD30-种植植物函数0041220E E8 0DC3FFFF call Plants_v.0040E520 从种植函数入口进行分析，寻找关键跳转。 1234560040FE25 57 push edi0040FE26 53 push ebx0040FE27 55 push ebp0040FE28 E8 F3E1FFFF call Plants_v.0040E020 ; 判断该方块是否可以种植植物0040FE2D 85C0 test eax,eax0040FE2F 0F84 1F090000 je Plants_v.00410754 ; 跳转为可种植 这里就是游戏对方块是否可以种植进行判断的代码。 两个所需的位置已经确定，想要实现无限种植，只需要对跳转代码进行修改，或者进一步分析判断函数。 最后实现效果。]]></content>
      <categories>
        <category>逆向分析</category>
        <category>游戏分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ESP脱壳法]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FSoftware%2FESP%E8%84%B1%E5%A3%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ESP脱壳方法是一种常用的快速手动脱壳的方法，针对一些常见的传统PE外壳很有效，但是并不适用所有的外壳。 演示使用UPX加壳notepad.exe。 0x1 环境 系统：Windows XP SP3 外壳：UPX v3.95 软件：notepad.exe 工具：PEiD v0.95、ExeinfoPE v0.0.5.1、吾爱破解专用版OllyDbg、ImportREConstructor v1.7e 0x2 操作1、加壳 使用UPX对notepad.exe进行加壳。 2、查壳 使用PEiD查壳，因为PEiD长久未更新，所以无法识别。 使用ExeinfoPE查壳，识别正确。 当使用一款查壳工具没有结果时，多试几种看看，说不定就有意外收获。 3、脱壳 载入OD，可能会提示代码被压缩，无视，继续分析。 加载成功后，即可看到外壳入口。 单步执行pushad指令，然后右键ESP寄存器，选择“数据窗口中跟随”，可以看到数据窗口中被压入内存中的各寄存器的值。 在第一个十六进制值上右键，下DWORD类型的硬件访问断点。 F9运行程序，OD将会中断在popad指令后。运行到一个大跳转过后，即可到达程序的OEP。 在程序OEP右键，选择“用OllyDump脱壳调试进程”。设置好入口地址，其他默认，点击脱壳完成Dump程序。 此时不能关闭OD，因为刚脱壳后的程序还未修复，所以无法运行，而修复程序则需要读取内存中的原IAT等地址。所以OD调试的进程不能关闭。 4、修复 打开ImportREConstructor，附加到脱壳进程。 在OEP输入框中输入OEP的地址，点击“IAT自动搜索”，程序将会自动搜索内存中的IAT地址。 发现原始IAT后，点击“获取导入表”，得到内存中导入表。 点击“修正转储”，选择刚刚脱壳的程序文件，进行修复。 等程序日志中提示保存成功后，便完成了修复。 此时程序已经脱壳，且可以正常运行了。]]></content>
      <categories>
        <category>逆向分析</category>
        <category>软件分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[植物大战僵尸之植物无CD]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FGame%2F%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E4%B9%8B%E6%A4%8D%E7%89%A9%E6%97%A0CD%2F</url>
    <content type="text"><![CDATA[继续分析植物大战僵尸，第四篇，这次的目标是植物无CD效果。 准备 系统：Windows 10 x64 专业版 软件：植物大战僵尸中文版 工具：CheatEngine v6.8.2、吾爱破解专用版OllyDbg 目标：植物无CD 分析整理思路。 在游戏中多次实验可以发现，当点击植物卡片时，会触发两种情况，一种是装填完毕，一种是未装填完毕。 猜测游戏中对植物装填状态有一个判断，而且是发生在点击植物卡片之后，所以，目标可以分为两个部分： 寻找植物卡片点击事件处理 寻找植物装填状态判断 进行分析。 1. 寻找植物卡片点击事件 第一个目标，可以将第三篇的植物种植函数来作为切入点。 搜索当前阳光存储地址，找出减少阳光值指令。 单步执行出种植函数。 1234567891011121314004121FE |. 8B4D 0C mov ecx,[arg.2] ; kernel32.772887DD00412201 |. 8B55 08 mov edx,[arg.1]00412204 |. 51 push ecx00412205 |. 52 push edx00412206 |. 57 push edi00412207 |. 8BCB mov ecx,ebx00412209 |. E8 22DBFFFF call Plants_v.0040FD30 ; 0x0040FD30-种植植物函数0041220E |. E8 0DC3FFFF call Plants_v.0040E52000412213 |. 5F pop edi ; 0019FD0000412214 |. 5E pop esi ; 0019FD0000412215 |. 5B pop ebx ; 0019FD0000412216 |. 8BE5 mov esp,ebp00412218 |. 5D pop ebp ; 0019FD0000412219 |. C2 0C00 retn 0xC 向上找到函数头部，下断，就可以发现该函数就是植物卡片点击事件处理函数。 2. 寻找植物装填状态判断 点击植物分为可种植和不可种植两种状态，所以从种植函数开始逆向分析点击事件处理函数。 种植函数上方就是一个判断跳转，简单分析可以猜测其功能是判断本次点击是否为放下植物。 1234004121F3 |. 8BC7 mov eax,edi004121F5 |. E8 E6AAFFFF call Plants_v.0040CCE0 ; 猜测-判断本次鼠标点击是否为放下植物004121FA |. 84C0 test al,al004121FC |. 74 1E je short Plants_v.0041221C 而且可以发现，无论植物是否装填完毕，都会运行到该函数位置。 对该函数的参数与返回结果进行比较分析。 确定无论是否装填完毕，同一植物情况下参数与返回结果都相同。 所以装填状态判断还在后面，继续单步分析。 跳转后出现两个函数， 1234567891011121314150041221C |&gt; \83FA 04 cmp edx,0x4 ; Switch (cases 1..F)0041221F |. 75 28 jnz short Plants_v.0041224900412221 |. 8B4424 10 mov eax,dword ptr ss:[esp+0x10] ; Case 4 of switch 0041221C00412225 |. 8B48 04 mov ecx,dword ptr ds:[eax+0x4]00412228 |. 80B9 64010000&gt;cmp byte ptr ds:[ecx+0x164],0x00041222F |. 0F85 EB000000 jnz Plants_v.0041232000412235 |. 50 push eax00412236 |. E8 55630700 call Plants_v.00488590 ; 冷却判断函数0041223B |. E8 E0C2FFFF call Plants_v.0040E52000412240 |. 5F pop edi ; 0019FD0000412241 |. 5E pop esi ; 0019FD0000412242 |. 5B pop ebx ; 0019FD0000412243 |. 8BE5 mov esp,ebp00412245 |. 5D pop ebp ; 0019FD0000412246 |. C2 0C00 retn 0xC 同样对齐进行参数比较后，发现 0x00488590 函数的参数与返回结果出现了变化。 以向日葵为对象（左为装填完毕，右为装填中）。 参数比较： 返回结果比较： 修改执行后的eax返回值，发现在装填状态下可以种植植物，确定该函数就是装填状态判断函数。 F7进入分析，确定关键跳转位置。 1200488684 |. 807D 48 00 cmp byte ptr ss:[ebp+0x48],0x0 ; 冷却判断00488688 |. 0F85 79010000 jnz Plants_v.00488807 ; 成功跳转 猜测 [ebp+0x48] 指向的内存地址为装填状态标志，0x00为装填中，0x01为装填完毕。 在标志上下内存写入断点，运行游戏，确定标志设置指令。 设置为装填中。 123400488E71 |&gt; \33C0 xor eax,eax ; Default case of switch 00488E3B00488E73 |. C645 48 00 mov byte ptr ss:[ebp+0x48],0x0 ; 修改装填标志为装填中00488E77 |. 8945 24 mov [arg.8],eax00488E7A |. 8945 28 mov [arg.9],eax 设置为装填完毕。 1234500487298 |. C747 24 00000&gt;mov dword ptr ds:[edi+0x24],0x00048729F |. C647 49 00 mov byte ptr ds:[edi+0x49],0x0004872A3 |. C647 48 01 mov byte ptr ds:[edi+0x48],0x1 ; 设置装填标志为装填完毕004872A7 |. E8 E4FEFFFF call Plants_v.00487190004872AC |&gt; 8B47 3C mov eax,dword ptr ds:[edi+0x3C] 分析完毕，只需要将设置为装填中的指令，修改为设置为装填完毕，即可实现植物无CD的目标。 效果如图：]]></content>
      <categories>
        <category>逆向分析</category>
        <category>游戏分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WinRAR去广告窗口]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FSoftware%2FWinRAR%E5%8E%BB%E5%B9%BF%E5%91%8A%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[WinRAR虽然推出了免费的中文个人版，但是新添加的广告窗口让人烦不胜烦。尽管理解其这种商业行为，不过对于个人来说，还是抗拒这种事情的。 之前曾经尝试过去除广告窗口，但是最后限于水平（现在也不咋地）而失败了。这次换了一种思路，发现还是很简单就可以去除的。 准备 系统：Windows 7 SP1 x64 ultimate 工具：吾爱破解专用版OllyDbg、x64dbg 软件：WinRAR 中文个人版 v5.6.1 32/64位 分析32位和64位的修改思路是一样的，但是作为记录的话，还是都写一下比较好。 大致思路如下： 根据WinRAR窗口出现的时间可以猜测，广告窗口是在主窗口之后被创建或者被设置为显示的，所以从窗口函数切入，确定其出现时所调用的窗口函数，然后进行分析。 32位在所有CreateWindowExW函数上下断点，根据堆栈中的函数参数来判断广告窗口的创建位置。 最后确定广告窗口出现时的CreateWindowExW为： 123456789101112131415161718012F07A0 |. 53 push ebx ; /lParam = 006D14E0012F07A1 |. FF33 push dword ptr ds:[ebx] ; |hInst = 01230000012F07A3 |. 6A 00 push 0x0 ; |hMenu = NULL012F07A5 |. 55 push ebp ; |/hWnd = 000302A2 (class=&apos;Static&apos;,parent=000402A6)012F07A6 |. FF15 20663401 call dword ptr ds:[&lt;&amp;USER32.GetParent&gt;] ; |\GetParent012F07AC |. 8B4C24 20 mov ecx,dword ptr ss:[esp+0x20] ; |apisetsc.000402A6012F07B0 |. 50 push eax ; |hParent = 000002D4012F07B1 |. 8B4424 2C mov eax,dword ptr ss:[esp+0x2C] ; |012F07B5 |. 2BC1 sub eax,ecx ; |012F07B7 |. 50 push eax ; |Height = 2D4 (724.)012F07B8 |. 56 push esi ; |Width = 39C (924.)012F07B9 |. 51 push ecx ; |Y = 0x0012F07BA |. 57 push edi ; |X = 0x0012F07BB |. 68 00000040 push 0x40000000 ; |Style = WS_CHILD012F07C0 |. 6A 00 push 0x0 ; |WindowName = NULL012F07C2 |. 68 C8D03401 push WinRAR.0134D0C8 ; |Class = &quot;RarHtmlClassName&quot;012F07C7 |. 6A 00 push 0x0 ; |ExtStyle = 0012F07C9 |. FF15 9C653401 call dword ptr ds:[&lt;&amp;USER32.CreateWindow&gt;; \CreateWindowExW 其参数为： 1234567891011120038A584 00000000 |ExtStyle = 00038A588 0134D0C8 |Class = &quot;RarHtmlClassName&quot;0038A58C 00000000 |WindowName = NULL0038A590 40000000 |Style = WS_CHILD0038A594 00000000 |X = 0x00038A598 00000000 |Y = 0x00038A59C 0000039C |Width = 39C (924.)0038A5A0 000002D4 |Height = 2D4 (724.)0038A5A4 00390230 |hParent = 00390230 (&apos;WinRAR&apos;,class=&apos;RarReminder&apos;)0038A5A8 00000000 |hMenu = NULL0038A5AC 01230000 |hInst = 012300000038A5B0 004E1BD8 \lParam = 004E1BD8 可以猜测这里是创建用于显示广告内容的窗口。 hParent参数显示了其父窗口的类型和窗口名，确定其父窗口创建位置。 窗口名为“WinRAR”，且前面紧挨着广告链接“https://ad.winrar.com.cn/show_2.html?L=7&amp;bl=7&amp;v=561personal&amp;a=32&amp;src=cn”。 可以推测这里就是广告窗口的创建位置。 去除的方式有很多，这里选择修改其Style参数为0。 修改位置有两处。 第一处为： 000C6F53 |. 81CF 0000C816 or edi,0x16C80000 修改为： 1234000C6F53 83CF 00 or edi,0x0000C6F56 90 nop000C6F57 90 nop000C6F58 90 nop 第二处为： 000C6F62 |. 81CF 00000300 or edi,0x30000 修改为： 1234000C6F62 83CF 00 or edi,0x0000C6F65 90 nop000C6F66 90 nop000C6F67 90 nop 保存文件即可实现去除广告窗口的效果。 64位64位的思路一样，操作步骤也差不多。 其窗口创建位置为： 第一处修改为： 000000013F0D15C1 | 81C9 0000C816 | or ecx,16C80000 | 修改为： 1234000000013F0D15C1 | 83C9 00 | or ecx,0 |000000013F0D15C4 | 90 | nop |000000013F0D15C5 | 90 | nop |000000013F0D15C6 | 90 | nop | 第二处修改为： 000000013F0D15C9 | 81CE 00000300 | or esi,30000 | 30000:&quot;Actx &quot; 修改为： 1234000000013F0D15C9 | 83CE 00 | or esi,0 |000000013F0D15CC | 90 | nop |000000013F0D15CD | 90 | nop |000000013F0D15CE | 90 | nop |]]></content>
      <categories>
        <category>逆向分析</category>
        <category>软件分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之001]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B001%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第1个。 0x1 环境 系统：Windows XP SP3 软件：Acid_burn.exe 工具：PEiD v0.95、吾爱破解专用版OllyDbg 0x2 分析运行程序，有三处需要分析的位置。一处初始弹窗，一处注册码注册，还有一处用户名与注册码注册。 先进行查壳，无壳，Borland Delphi 3.0 编写。 首先去除初始弹窗。 将程序拖入OD，搜素弹窗内容字符串，定位弹窗函数。 1234560042F784 . 6A 00 push 0x00042F786 . B9 A0F74200 mov ecx,Acid_bur.0042F7A0 ; hello you have to kill me!0042F78B . BA BCF74200 mov edx,Acid_bur.0042F7BC ; Welcome to this Newbies Crackme made by ACiD BuRN [CracKerWoRlD]0042F790 . A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042F795 . 8B00 mov eax,dword ptr ds:[eax]0042F797 . E8 D4A9FFFF call Acid_bur.0042A170 ; 弹窗函数 将 0x0042F784 处的push 0x0修改为retn，即可去除弹窗。 然后分析只需要注册码的注册窗口。 输入假码，获得失败提示。 OD中搜索字符串，确定该错误提示，定位注册函数。 123456789101112131415161718190042F48A |. 8D45 FC lea eax,[local.1]0042F48D |. BA 40F54200 mov edx,Acid_bur.0042F540 ; Hello0042F492 |. E8 7142FDFF call Acid_bur.004037080042F497 |. 8D45 F8 lea eax,[local.2]0042F49A |. BA 50F54200 mov edx,Acid_bur.0042F550 ; Dude!0042F49F |. E8 6442FDFF call Acid_bur.004037080042F4A4 |. FF75 FC push [local.1] ; Acid_bur.0042F5400042F4A7 |. 68 60F54200 push Acid_bur.0042F5600042F4AC |. FF75 F8 push [local.2] ; Acid_bur.0042F5500042F4AF |. 8D45 F4 lea eax,[local.3]0042F4B2 |. BA 03000000 mov edx,0x30042F4B7 |. E8 F044FDFF call Acid_bur.004039AC ; 获得正确注册码0042F4BC |. 8D55 F0 lea edx,[local.4]0042F4BF |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]0042F4C5 |. E8 8EB5FEFF call Acid_bur.0041AA58 ; 获取输入注册码0042F4CA |. 8B45 F0 mov eax,[local.4]0042F4CD |. 8B55 F4 mov edx,[local.3]0042F4D0 |. E8 2745FDFF call Acid_bur.004039FC ; 验证函数0042F4D5 |. 75 1A jnz short Acid_bur.0042F4F1 ; 跳转为注册失败，不跳转为注册成功 0x0042F4D0 处函数的参数为正确注册码与输入注册码，在该处下断，得到正确的注册码为Hello Dude!。 最后分析需要用户名和注册码共同注册的窗口。 输入任意用户名与假码，获得错误提示。 OD中搜索该字符串，确定字符串位置，定位注册函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879800042F9BF |. 8D55 F0 lea edx,[local.4]0042F9C2 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042F9C8 |. E8 8BB0FEFF call Acid_bur.0041AA58 ; 获取用户名0042F9CD |. 8B45 F0 mov eax,[local.4]0042F9D0 |. E8 DB40FDFF call Acid_bur.00403AB00042F9D5 |. A3 6C174300 mov dword ptr ds:[0x43176C],eax ; Acid_bur.0042FAEA0042F9DA |. 8D55 F0 lea edx,[local.4]0042F9DD |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042F9E3 |. E8 70B0FEFF call Acid_bur.0041AA580042F9E8 |. 8B45 F0 mov eax,[local.4]0042F9EB |. 0FB600 movzx eax,byte ptr ds:[eax] ; 获取用户名第一个字符0042F9EE |. 8BF0 mov esi,eax ; Acid_bur.0042FAEA0042F9F0 |. C1E6 03 shl esi,0x3 ; 逻辑左移3位0042F9F3 |. 2BF0 sub esi,eax ; 左移后的结果减去原字符0042F9F5 |. 8D55 EC lea edx,[local.5]0042F9F8 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042F9FE |. E8 55B0FEFF call Acid_bur.0041AA580042FA03 |. 8B45 EC mov eax,[local.5]0042FA06 |. 0FB640 01 movzx eax,byte ptr ds:[eax+0x1] ; 获取用户名第二个字符0042FA0A |. C1E0 04 shl eax,0x4 ; 逻辑左移4位0042FA0D |. 03F0 add esi,eax ; 加上上一次的结果0042FA0F |. 8935 54174300 mov dword ptr ds:[0x431754],esi0042FA15 |. 8D55 F0 lea edx,[local.4]0042FA18 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA1E |. E8 35B0FEFF call Acid_bur.0041AA580042FA23 |. 8B45 F0 mov eax,[local.4]0042FA26 |. 0FB640 03 movzx eax,byte ptr ds:[eax+0x3] ; 获取用户名第4个字符0042FA2A |. 6BF0 0B imul esi,eax,0xB ; 与0xB相乘0042FA2D |. 8D55 EC lea edx,[local.5]0042FA30 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA36 |. E8 1DB0FEFF call Acid_bur.0041AA580042FA3B |. 8B45 EC mov eax,[local.5]0042FA3E |. 0FB640 02 movzx eax,byte ptr ds:[eax+0x2] ; 获取用户名第3个字符0042FA42 |. 6BC0 0E imul eax,eax,0xE ; 与0xE相乘0042FA45 |. 03F0 add esi,eax ; 与上一次结果相加0042FA47 |. 8935 58174300 mov dword ptr ds:[0x431758],esi0042FA4D |. A1 6C174300 mov eax,dword ptr ds:[0x43176C]0042FA52 |. E8 D96EFDFF call Acid_bur.004069300042FA57 |. 83F8 04 cmp eax,0x40042FA5A |. 7D 1D jge short Acid_bur.0042FA79 ; 用户名长度需要大于等于40042FA5C |. 6A 00 push 0x00042FA5E |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again!0042FA63 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect !0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FA6D |. 8B00 mov eax,dword ptr ds:[eax]0042FA6F |. E8 FCA6FFFF call Acid_bur.0042A1700042FA74 |. E9 BE000000 jmp Acid_bur.0042FB370042FA79 |&gt; 8D55 F0 lea edx,[local.4]0042FA7C |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA82 |. E8 D1AFFEFF call Acid_bur.0041AA580042FA87 |. 8B45 F0 mov eax,[local.4]0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取出用户名第一个字符0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; 与0x29相乘0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax ; Acid_bur.0042FAEA0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; 结果与结果相加0042FAA3 |. 8D45 FC lea eax,[local.1]0042FAA6 |. BA ACFB4200 mov edx,Acid_bur.0042FBAC ; CW0042FAAB |. E8 583CFDFF call Acid_bur.004037080042FAB0 |. 8D45 F8 lea eax,[local.2]0042FAB3 |. BA B8FB4200 mov edx,Acid_bur.0042FBB8 ; CRACKED0042FAB8 |. E8 4B3CFDFF call Acid_bur.004037080042FABD |. FF75 FC push [local.1] ; Acid_bur.0042FBAC0042FAC0 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FAC5 |. 8D55 E8 lea edx,[local.6]0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FACD |. E8 466CFDFF call Acid_bur.00406718 ; 将上一次计算结果的十进制转为字符串0042FAD2 |. FF75 E8 push [local.6]0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FADA |. FF75 F8 push [local.2] ; Acid_bur.0042FBB80042FADD |. 8D45 F4 lea eax,[local.3]0042FAE0 |. BA 05000000 mov edx,0x50042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC ; 获取正确注册码0042FAEA |. 8D55 F0 lea edx,[local.4]0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA58 ; 获取输入假码0042FAF8 |. 8B55 F0 mov edx,[local.4] ; 假码0042FAFB |. 8B45 F4 mov eax,[local.3] ; 真码0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ; 验证函数0042FB03 |. 75 1A jnz short Acid_bur.0042FB1F ; 跳转为注册失败，不跳转为注册成功 分析注册算法为： 判断用户名的长度是否大于等于4。 用户名第一个字符的ascii码 * 0x29。 第一步结果与自己相加，即乘2。 将第二步结果的十进制用字符串表示。 连接字符串CW-&lt;第三步字符串&gt;-CRACKED。 例如用户名为test，则注册码为CW-9512-CRACKED。 0x3 参考 [反汇编练习]160个CrackMe之001]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之003]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B003%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第三个。 0x1 环境 系统：Windows XP SP3 软件：AfKayAs.2.exe 工具：PEiD v095、吾爱破解专用版OllyDbg 0x2 分析运行程序，提示需要完成两个目标。 去除 Nag 窗口。 找到成功注册的用户名和注册码。 首先进行查壳，无壳，Microsoft Visual Basic 编写。 目标1：去除Nag窗口 针对 VB 5.0 程序，采用刚刚从吾爱学习到的4C法。 载入OD后，入口为 push 指令，和 call 指令。 1200401170 &gt; $ 68 D4674000 push AfKayAs_.004067D400401175 . E8 F0FFFFFF call &lt;jmp.&amp;MSVBVM50.#ThunRTMain_100&gt; 将 push 指令后的操作数加上 0x4C，作为数据窗口跟随的地址，即 0x00406820。 继续跟随 0x00406820 处的DWORD类型的值 0x00406868。 其中标记的数据是VB需要加载的两块代码（即加载的窗体代码），每块代码的第24字节处是该代码块被加载的顺序。第一块为 0x00（Nag窗口），第二块为 0x01（注册窗口）。 将两块代码的加载顺序互换，即第一块为 0x01，第二块为 0x00。代表首先加载注册窗口的代码，而注册窗口关闭后，程序退出，所以Nag窗口实际上不会被执行，即被去除。 目标2：找到成功注册的用户名和注册码 输入任意用户名和注册码，获得失败提示。 载入OD，搜索字符串，确定失败字符串，找到关键跳转。 123456700408665 . 66:85F6 test si,si00408668 . 8945 94 mov dword ptr ss:[ebp-0x6C],eax0040866B . 894D AC mov dword ptr ss:[ebp-0x54],ecx0040866E . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax00408671 . 894D BC mov dword ptr ss:[ebp-0x44],ecx00408674 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax00408677 . 74 62 je short AfKayAs_.004086DB ; 跳转为注册失败，不跳转为注册成功 向上分析，找到比较代码。 12345678910111213141516171819202122232425004085CE &gt; \8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; 取出输入的注册码004085D1 . 50 push eax004085D2 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; msvbvm50.__vbaR8Str004085D8 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] ; 取出正确的注册码004085DB . DD9D 1CFFFFFF fstp qword ptr ss:[ebp-0xE4] ; 假码放入内存作为除数004085E1 . 51 push ecx004085E2 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; msvbvm50.__vbaR8Str004085E8 . 833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0004085EF . 75 08 jnz short AfKayAs_.004085F9004085F1 . DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4] ; 真码除以假码004085F7 . EB 11 jmp short AfKayAs_.0040860A004085F9 &gt; FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0]004085FF . FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4]00408605 . E8 888AFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt;0040860A &gt; DFE0 fstsw ax0040860C . A8 0D test al,0xD0040860E . 0F85 AB010000 jnz AfKayAs_.004087BF00408614 . FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt;; msvbvm50.__vbaFpR80040861A . DC1D 28104000 fcomp qword ptr ds:[0x401028] ; 比较运算结果是否为100408620 . DFE0 fstsw ax00408622 . F6C4 40 test ah,0x4000408625 . 74 07 je short AfKayAs_.0040862E00408627 . BE 01000000 mov esi,0x1 ; 注册标志置10040862C . EB 02 jmp short AfKayAs_.004086300040862E &gt; 33F6 xor esi,esi ; 注册标志置0 继续向上，找到计算注册码的算法，共有四块代码。 12345678910111213141516171819004081E9 &gt; \8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]004081EF . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; 取出用户名004081F2 . 50 push eax ; /String = &quot;355668&quot;004081F3 . 8B1A mov ebx,dword ptr ds:[edx] ; |004081F5 . FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \__vbaLenBstr004081FB . 8BF8 mov edi,eax004081FD . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00408200 . 69FF 385B0100 imul edi,edi,0x15B38 ; 用户名长度 乘以 0x15B3800408206 . 51 push ecx ; /String = &quot;\^&quot;00408207 . 0F80 B7050000 jo AfKayAs_.004087C4 ; |0040820D . FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr00408213 . 0FBFD0 movsx edx,ax ; 获取用户名第一个字符的ASCII码00408216 . 03FA add edi,edx ; 加上前面的乘法结果00408218 . 0F80 A6050000 jo AfKayAs_.004087C40040821E . 57 push edi0040821F . FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; msvbvm50.__vbaStrI400408225 . 8BD0 mov edx,eax ; 转为十进制表示的字符串00408227 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]0040822A . FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove 12345678910111213141516171819202122232425004082DD &gt; \8B8D 58FFFFFF mov ecx,dword ptr ss:[ebp-0xA8]004082E3 . 8B55 E8 mov edx,dword ptr ss:[ebp-0x18]004082E6 . 52 push edx004082E7 . 8B19 mov ebx,dword ptr ds:[ecx]004082E9 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; msvbvm50.__vbaR8Str004082EF . D905 08104000 fld dword ptr ds:[0x401008] ; 压入 0x10004082F5 . 833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0004082FC . 75 08 jnz short AfKayAs_.00408306004082FE . D835 0C104000 fdiv dword ptr ds:[0x40100C] ; 0x10 除以 0x500408304 . EB 0B jmp short AfKayAs_.0040831100408306 &gt; FF35 0C104000 push dword ptr ds:[0x40100C]0040830C . E8 578DFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt;00408311 &gt; 83EC 08 sub esp,0x800408314 . DFE0 fstsw ax00408316 . A8 0D test al,0xD00408318 . 0F85 A1040000 jnz AfKayAs_.004087BF0040831E . DEC1 faddp st(1),st ; 加上前面的除法结果，即 0x200408320 . DFE0 fstsw ax00408322 . A8 0D test al,0xD00408324 . 0F85 95040000 jnz AfKayAs_.004087BF0040832A . DD1C24 fstp qword ptr ss:[esp]0040832D . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; msvbvm50.__vbaStrR800408333 . 8BD0 mov edx,eax00408335 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]00408338 . FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove 12345678910111213141516004083E9 &gt; \8B8D 58FFFFFF mov ecx,dword ptr ss:[ebp-0xA8]004083EF . 8B55 E8 mov edx,dword ptr ss:[ebp-0x18]004083F2 . 52 push edx004083F3 . 8B19 mov ebx,dword ptr ds:[ecx]004083F5 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; msvbvm50.__vbaR8Str004083FB . DC0D 10104000 fmul qword ptr ds:[0x401010] ; 乘以 0x300408401 . 83EC 08 sub esp,0x800408404 . DC25 18104000 fsub qword ptr ds:[0x401018] ; 减去 0x20040840A . DFE0 fstsw ax0040840C . A8 0D test al,0xD0040840E . 0F85 AB030000 jnz AfKayAs_.004087BF00408414 . DD1C24 fstp qword ptr ss:[esp]00408417 . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; msvbvm50.__vbaStrR80040841D . 8BD0 mov edx,eax0040841F . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]00408422 . FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove 123456789101112131415004084D3 &gt; \8B8D 58FFFFFF mov ecx,dword ptr ss:[ebp-0xA8]004084D9 . 8B55 E8 mov edx,dword ptr ss:[ebp-0x18]004084DC . 52 push edx004084DD . 8B19 mov ebx,dword ptr ds:[ecx]004084DF . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; msvbvm50.__vbaR8Str004084E5 . DC25 20104000 fsub qword ptr ds:[0x401020] ; 加 0x15004084EB . 83EC 08 sub esp,0x8004084EE . DFE0 fstsw ax004084F0 . A8 0D test al,0xD004084F2 . 0F85 C7020000 jnz AfKayAs_.004087BF004084F8 . DD1C24 fstp qword ptr ss:[esp]004084FB . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; msvbvm50.__vbaStrR800408501 . 8BD0 mov edx,eax ; 得到正确的注册码00408503 . 8D4D E4 lea ecx,dword ptr ss:[ebp-0x1C]00408506 . FF15 94B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrMo&gt;; msvbvm50.__vbaStrMove 整个计算过程很简单： 用户名的长度与 * 0x15B38 。 用户名第一个字符的ASCII码 + 第一步结果，结果转为十进制表示的十六进制。 第二步结果 + 0x10 / 0x5。 第三步结果 * 0x3 - 0x2。 第四步结果 + 0x15 。 第五步结果转为字符串。 例如：用户名为“test”，计算过程为： 0x4 * 0x15B38 = 0x56CE0。 0x56CE0 + 0x74 = 0x56D54（355668），转为 0x355668。 0x355668 + 0x10 / 0x5 = 0x355670。 0x355670 * 0x3 - 0x2 = 0x1067008。 0x1067008 + 0x15 = 0x1067023。 注册码为”1067023”。 输入用户名和注册码验证。 0x3 参考 [反汇编练习] 160个CrackMe之003 (出处: 吾爱破解论坛) 160个crackme之003 Afkayas 去VB程序NAG窗口方法-4C法 (出处: 吾爱破解论坛) 完全新手教程：使用OllyDbg从零开始Cracking (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之006]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B006%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第6个。 0x1 环境 系统：Windows XP SP3 软件：aLoNg3x.1.exe 工具：PEiD v0.95、吾爱破解专用版OllyDbg、DeDe v3.50.04 0x2 分析运行程序，需要用户名和注册码，且OK按钮是不可点击的。 PEiD查壳，无壳，Borland Delphi 编写。 Delphi程序，拖入DeDe查看。找到10个过程事件函数。 因为OK按钮无法使用，所以程序应该是每次输入来检测用户名和注册码的。所以先分析“NomeChange”和“CodiceChange”函数。 1.NomeChange 函数逻辑很简单，验证Nome和Codice，通过则更改OK按钮为可用。 123456789101112131415161718192021222300442E37 |&gt; \8D55 FC lea edx,[local.1]00442E3A |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442E40 |. E8 7B04FEFF call aLoNg3x_.004232C0 ; 获取Codice00442E45 |. 8B45 FC mov eax,[local.1]00442E48 |. 50 push eax00442E49 |. 8D55 F8 lea edx,[local.2]00442E4C |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442E52 |. E8 6904FEFF call aLoNg3x_.004232C0 ; 获取Nome00442E57 |. 8B45 F8 mov eax,[local.2]00442E5A |. 5A pop edx ; 0012F3CC00442E5B |. E8 DCFBFFFF call aLoNg3x_.00442A3C ; 验证Nome和Codice00442E60 |. 84C0 test al,al00442E62 |. 74 0F je short aLoNg3x_.00442E7300442E64 |. B2 01 mov dl,0x100442E66 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E6C |. 8B08 mov ecx,dword ptr ds:[eax]00442E6E |. FF51 60 call dword ptr ds:[ecx+0x60] ; 更改OK按钮为可用00442E71 |. EB 0D jmp short aLoNg3x_.00442E8000442E73 |&gt; 33D2 xor edx,edx00442E75 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E7B |. 8B08 mov ecx,dword ptr ds:[eax]00442E7D |. FF51 60 call dword ptr ds:[ecx+0x60] ; 更改OK按钮为不可用00442E80 |&gt; 33C0 xor eax,eax 对验证函数 “_PROC_00442A3C” 进行分析。 2._PROC_00442A3C 首先检测Nome长度是否大于5。 123400442A68 |. 8B45 FC mov eax,[local.1]00442A6B |. E8 C40FFCFF call aLoNg3x_.00403A34 ; 计算用户名长度00442A70 |. 83F8 05 cmp eax,0x500442A73 |. 7E 53 jle short aLoNg3x_.00442AC8 ; 用户名长度需要大于5 根据Nome计算出验证码。 123456789101112131400442A89 |. 4A dec edx00442A8A |. 85D2 test edx,edx00442A8C |. 7E 20 jle short aLoNg3x_.00442AAE00442A8E |. B8 01000000 mov eax,0x100442A93 |&gt; 8B4D FC /mov ecx,[local.1]00442A96 |. 0FB64C01 FF |movzx ecx,byte ptr ds:[ecx+eax-0x1]00442A9B |. 8B75 FC |mov esi,[local.1]00442A9E |. 0FB63406 |movzx esi,byte ptr ds:[esi+eax]00442AA2 |. 0FAFCE |imul ecx,esi00442AA5 |. 0FAFC8 |imul ecx,eax00442AA8 |. 03D9 |add ebx,ecx00442AAA |. 40 |inc eax00442AAB |. 4A |dec edx00442AAC |.^ 75 E5 \jnz short aLoNg3x_.00442A93 计算流程如下： 123456int i;long code = strlen(Nome);for(i = 0; i &lt; strlen(Nome) - 1; i++)&#123; code += Nome[i] * Nome[i+1] * (i+1);&#125; 与Codice相减，进行判断。 123456700442AAE |&gt; \8B45 F8 mov eax,[local.2]00442AB1 |. E8 BA4BFCFF call aLoNg3x_.00407670 ; 转为十六进制00442AB6 |. 2BD8 sub ebx,eax00442AB8 |. 81FB 9A020000 cmp ebx,0x29A ; Codice与验证码相差 0x29A00442ABE |. 75 04 jnz short aLoNg3x_.00442AC400442AC0 |. B3 01 mov bl,0x100442AC2 |. EB 06 jmp short aLoNg3x_.00442ACA 例如Nome为“tested”，则Codice为“171670”。 Nome与Codice正确之后，OK按钮变得可用。接着分析“OkClick”函数。 3.OkClick 检测某个标志，不通过则清除Codice，通过则隐藏OK按钮。 12300442D7A |. 8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]00442D80 |. 8078 47 01 cmp byte ptr ds:[eax+0x47],0x1 ; 检测标志00442D84 |. 75 12 jnz short aLoNg3x_.00442D98 搜索常量 0x2D0，最终确定在 “CancellaClick”函数中可以修改该标志。 验证Nome与Codice。 123456789101112131400442D98 |&gt; \8D55 FC lea edx,[local.1]00442D9B |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442DA1 |. E8 1A05FEFF call aLoNg3x_.004232C0 ; 获取Codice00442DA6 |. 8B45 FC mov eax,[local.1]00442DA9 |. E8 C248FCFF call aLoNg3x_.00407670 ; 转为十六进制00442DAE |. 50 push eax00442DAF |. 8D55 FC lea edx,[local.1]00442DB2 |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442DB8 |. E8 0305FEFF call aLoNg3x_.004232C0 ; 获取Nome00442DBD |. 8B45 FC mov eax,[local.1]00442DC0 |. 5A pop edx ; 0012F97C00442DC1 |. E8 DAFDFFFF call aLoNg3x_.00442BA0 ; 验证Nome与Codice00442DC6 |. 84C0 test al,al00442DC8 |. 74 0D je short aLoNg3x_.00442DD7 ; 跳转为验证失败，不跳转为验证成功 验证函数为”_PROC_00442BA0”。 4.CancellaClick 函数中对Nome和Codice进行了验证。 123456789101112131400442EBE |. 8D55 FC lea edx,[local.1]00442EC1 |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442EC7 |. E8 F403FEFF call aLoNg3x_.004232C0 ; 获取Codice00442ECC |. 8B45 FC mov eax,[local.1]00442ECF |. E8 9C47FCFF call aLoNg3x_.00407670 ; 转为十六进制00442ED4 |. 50 push eax00442ED5 |. 8D55 FC lea edx,[local.1]00442ED8 |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442EDE |. E8 DD03FEFF call aLoNg3x_.004232C0 ; 获取Nome00442EE3 |. 8B45 FC mov eax,[local.1]00442EE6 |. 5A pop edx ; 0012F67400442EE7 |. E8 08FCFFFF call aLoNg3x_.00442AF4 ; 比较Nome和Codice00442EEC |. 84C0 test al,al00442EEE |. 74 1C je short aLoNg3x_.00442F0C ; 跳转为验证失败，不跳转为验证成功 对验证函数 “_PROC_00442AF4”进行分析。 5._PROC_00442AF4 检查Nome长度。 123400442B18 |. 8B45 FC mov eax,[local.1]00442B1B |. E8 140FFCFF call aLoNg3x_.00403A34 ; 计算Nome长度00442B20 |. 83F8 05 cmp eax,0x500442B23 |. 7E 53 jle short aLoNg3x_.00442B78 ; Nome长度必须大于5 计算key。 12345678910111200442B18 |. 8B45 FC mov eax,[local.1]00442B1B |. E8 140FFCFF call aLoNg3x_.00403A34 ; 计算Nome长度00442B20 |. 83F8 05 cmp eax,0x500442B23 |. 7E 53 jle short aLoNg3x_.00442B78 ; Nome长度必须大于500442B25 |. 8B45 FC mov eax,[local.1]00442B28 |. 0FB640 04 movzx eax,byte ptr ds:[eax+0x4] ; Nome第二位00442B2C |. B9 07000000 mov ecx,0x700442B31 |. 33D2 xor edx,edx00442B33 |. F7F1 div ecx ; Nome[1] / 0x700442B35 |. 8BC2 mov eax,edx ; 取余数00442B37 |. 83C0 02 add eax,0x2 ; 余数 + 0x200442B3A |. E8 E1FEFFFF call aLoNg3x_.00442A20 ; 阶乘 计算验证码。 12345678910111200442B43 |. 8B45 FC mov eax,[local.1]00442B46 |. E8 E90EFCFF call aLoNg3x_.00403A34 ; 计算Nome长度00442B4B |. 85C0 test eax,eax00442B4D |. 7E 16 jle short aLoNg3x_.00442B6500442B4F |. BA 01000000 mov edx,0x100442B54 |&gt; 8B4D FC /mov ecx,[local.1]00442B57 |. 0FB64C11 FF |movzx ecx,byte ptr ds:[ecx+edx-0x1]00442B5C |. 0FAFCE |imul ecx,esi ; Nome每一个字符与key相乘00442B5F |. 03D9 |add ebx,ecx00442B61 |. 42 |inc edx00442B62 |. 48 |dec eax00442B63 |.^ 75 EF \jnz short aLoNg3x_.00442B54 比较注册码。 12300442B65 |&gt; \2B5D F8 sub ebx,[local.2]00442B68 |. 81FB 697A0000 cmp ebx,0x7A69 ; 验证码与注册码相差 0x7A6900442B6E |. 75 04 jnz short aLoNg3x_.00442B74 ; 跳转为验证失败，不跳转为验证通过 该函数的算法为： 12345678int i, key = 0;long code = 0;key = Nome[1] % 0x7 + 0x2;for(i = 0; i &lt; strlen(Nome); i++)&#123; code += Nome[i] * key;&#125; 例如，Nome为“tested”，Codice为”46543”。 6._PROC_00442BA0 检测Codice长度。 123400442BDD |. 8B45 F8 mov eax,[local.2]00442BE0 |. E8 4F0EFCFF call aLoNg3x_.00403A34 ; 计算Codice长度00442BE5 |. 83F8 05 cmp eax,0x500442BE8 |. 7E 60 jle short aLoNg3x_.00442C4A ; Codice长度必须大于5 将Codice变换为大写字母。 12345678910111213141516171800442BF9 |&gt; /8D45 F4 /lea eax,[local.3]00442BFC |. |E8 0310FCFF |call aLoNg3x_.00403C0400442C01 |. |8D4430 FF |lea eax,dword ptr ds:[eax+esi-0x1] ; 指向Codice最后一个字符00442C05 |. |50 |push eax00442C06 |. |8B45 F8 |mov eax,[local.2]00442C09 |. |0FB64430 FF |movzx eax,byte ptr ds:[eax+esi-0x1] ; 从Codice末尾开始依次取出字符00442C0E |. |F7E8 |imul eax ; 平方00442C10 |. |0FBFC0 |movsx eax,ax00442C13 |. |F7EE |imul esi ; 乘以本身的位置00442C15 |. |B9 19000000 |mov ecx,0x1900442C1A |. |99 |cdq00442C1B |. |F7F9 |idiv ecx00442C1D |. |83C2 41 |add edx,0x4100442C20 |. |58 |pop eax ; 0012F67400442C21 |. |8810 |mov byte ptr ds:[eax],dl00442C23 |. |4E |dec esi00442C24 |. |85F6 |test esi,esi00442C26 |.^\75 D1 \jnz short aLoNg3x_.00442BF9 与Nome比较。 123400442C28 |&gt; \8B45 F4 mov eax,[local.3]00442C2B |. 8B55 FC mov edx,[local.1]00442C2E |. E8 110FFCFF call aLoNg3x_.00403B4400442C33 |. 75 17 jnz short aLoNg3x_.00442C4C ; 跳转为验证失败，不跳转为验证成功 例如，Codice为“123456”，Nome为“BADQUV”。 所以整个验证过程为： 输入Nome=”tested”，Codice=”46543”； 点击Cancella按钮，该按钮会消失，OK按钮显示可用； 输入Nome=”BADQUV”，Codice=”123456”； 点击OK按钮，该按钮也消失，注册成功。 0x3 参考 初练160个CrakeMe程序之006 (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之007]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B007%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第7个。 0x1 环境 系统：Windows XP SP3 软件：aLoNg3x.2.exe 工具：PEiD v0.95、吾爱破解专用版OllyDbg、DeDe v3.50.04 0x2 分析运行程序，查看作者提示，最终需要将注册按钮隐藏起来。 PEiD查壳，无壳，Borland Delphi 编写。 拖入DeDe进行反编译，找到9个过程事件函数。 不输入任何注册名和注册码，可以得到提示。 载入OD搜索字符串，确定在RegisterzClick函数中。 1.RegisterzClick 检测注册码是否有效，并验证注册名和注册码。 123456789101112131415161718192021222324252627282930313200442F45 |. 8D55 F8 lea edx,[local.2]00442F48 |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442F4E |. E8 ED02FEFF call aLoNg3x_.00423240 ; 获取注册码00442F53 |. 8B45 F8 mov eax,[local.2]00442F56 |. 8D55 FC lea edx,[local.1]00442F59 |. E8 FAF9FBFF call aLoNg3x_.00402958 ; 转为十六进制00442F5E |. 8BF0 mov esi,eax00442F60 |. 837D FC 00 cmp [local.1],0x0 ; 判断注册码是否为有效输入00442F64 |. 74 37 je short aLoNg3x_.00442F9D00442F66 |. B8 38304400 mov eax,aLoNg3x_.00443038 ; You MUST insert a valid Long Integer Value in the Code Editor... Thank you :)00442F6B |. E8 00F6FFFF call aLoNg3x_.00442570 ; 弹出提示框00442F70 |. 8D55 F8 lea edx,[local.2]00442F73 |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442F79 |. E8 C202FEFF call aLoNg3x_.00423240 ; 计算注册码长度00442F7E |. 8B45 F8 mov eax,[local.2]00442F81 |. E8 06FBFFFF call aLoNg3x_.00442A8C ; 计算key00442F86 |. A3 30584400 mov dword ptr ds:[0x445830],eax00442F8B |. BA 90304400 mov edx,aLoNg3x_.00443090 ; 000442F90 |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442F96 |. E8 D502FEFF call aLoNg3x_.00423270 ; 清空注册码框内容00442F9B |. EB 6F jmp short aLoNg3x_.0044300C00442F9D |&gt; 85F6 test esi,esi ; 判断注册码是否为空00442F9F |. 7E 5A jle short aLoNg3x_.00442FFB00442FA1 |. 8D55 F8 lea edx,[local.2]00442FA4 |. 8B83 D8020000 mov eax,dword ptr ds:[ebx+0x2D8]00442FAA |. E8 9102FEFF call aLoNg3x_.00423240 ; 获取注册名00442FAF |. 8B4D F8 mov ecx,[local.2]00442FB2 |. 8BD6 mov edx,esi00442FB4 |. A1 30584400 mov eax,dword ptr ds:[0x445830]00442FB9 |. E8 EAF9FFFF call aLoNg3x_.004429A8 ; 验证注册名和注册码00442FBE |. 84C0 test al,al00442FC0 |. 74 30 je short aLoNg3x_.00442FF2 验证函数 _PROC_004429A8有三个参数，依次是：保存在 0x445830 的key、注册码的十六进制表示、注册名。 第一个参数key默认为0，由 _PROC_00442A8C 函数计算出。想运行到该函数，需要先输入无效的注册码，key由该无效的注册码计算出。 验证通过后隐藏Register按钮，显示again!!!按钮。 2._PROC_00442A8C 循环计算。 12345678910111213141516171819202122232425262728293031323300442AB9 |. BE 7B030000 mov esi,0x37B00442ABE |. 8B45 FC mov eax,[local.1]00442AC1 |. E8 6E0FFCFF call aLoNg3x_.00403A3400442AC6 |. 8BD8 mov ebx,eax00442AC8 |. 4B dec ebx00442AC9 |. 85DB test ebx,ebx00442ACB |. 7E 2B jle short aLoNg3x_.00442AF800442ACD |. B9 01000000 mov ecx,0x100442AD2 |&gt; 8B45 FC /mov eax,[local.1]00442AD5 |. 0FB60408 |movzx eax,byte ptr ds:[eax+ecx]00442AD9 |. BF 11000000 |mov edi,0x1100442ADE |. 33D2 |xor edx,edx00442AE0 |. F7F7 |div edi00442AE2 |. 42 |inc edx00442AE3 |. 8B45 FC |mov eax,[local.1]00442AE6 |. 0FB64408 FF |movzx eax,byte ptr ds:[eax+ecx-0x1]00442AEB |. 0FAFD0 |imul edx,eax00442AEE |. 03F2 |add esi,edx00442AF0 |. 41 |inc ecx00442AF1 |. 4B |dec ebx00442AF2 |.^ 75 DE \jnz short aLoNg3x_.00442AD200442AF4 |. EB 02 jmp short aLoNg3x_.00442AF800442AF6 |&gt; 33F6 xor esi,esi00442AF8 |&gt; 8BC6 mov eax,esi00442AFA |. B9 48710000 mov ecx,0x714800442AFF |. 99 cdq00442B00 |. F7F9 idiv ecx00442B02 |. 8BC2 mov eax,edx00442B04 |. 99 cdq00442B05 |. 33C2 xor eax,edx00442B07 |. 2BC2 sub eax,edx00442B09 |. 8BD8 mov ebx,eax00442B0B |. 33C0 xor eax,eax 对应算法伪代码为： 123456789int i;long sum = 0x37B;for(i = 1; i &lt; strlen(Codice); i++)&#123; sum += (Codice[i] % 0x11 + 0x1) * Codice[i - 1];&#125;sum = sum % 0x7148; 3._PROC_004429A8 得到key之后，就可以正常进行验证计算了。 1234567891011121314151617181920212223242526272829303132333435363738004429EE |. 8945 F4 mov [local.3],eax004429F1 |. BE 01000000 mov esi,0x1004429F6 |&gt; 8B45 F8 /mov eax,[local.2]004429F9 |. E8 3610FCFF |call aLoNg3x_.00403A34004429FE |. 83F8 01 |cmp eax,0x100442A01 |. 7C 1D |jl short aLoNg3x_.00442A2000442A03 |&gt; 8B55 F8 |/mov edx,[local.2]00442A06 |. 0FB65432 FF ||movzx edx,byte ptr ds:[edx+esi-0x1] ; 从注册名开头取字符00442A0B |. 8B4D F8 ||mov ecx,[local.2]00442A0E |. 0FB64C01 FF ||movzx ecx,byte ptr ds:[ecx+eax-0x1] ; 从注册名末尾取字符00442A13 |. 0FAFD1 ||imul edx,ecx00442A16 |. 0FAFD7 ||imul edx,edi00442A19 |. 03DA ||add ebx,edx00442A1B |. 48 ||dec eax00442A1C |. 85C0 ||test eax,eax00442A1E |.^ 75 E3 |\jnz short aLoNg3x_.00442A0300442A20 |&gt; 46 |inc esi00442A21 |. FF4D F4 |dec [local.3]00442A24 |.^ 75 D0 \jnz short aLoNg3x_.004429F600442A26 |&gt; 8BC3 mov eax,ebx00442A28 |. 99 cdq00442A29 |. 33C2 xor eax,edx00442A2B |. 2BC2 sub eax,edx00442A2D |. B9 2A2C0A00 mov ecx,0xA2C2A00442A32 |. 99 cdq00442A33 |. F7F9 idiv ecx00442A35 |. 8BDA mov ebx,edx00442A37 |. 8B45 FC mov eax,[local.1]00442A3A |. B9 59000000 mov ecx,0x5900442A3F |. 99 cdq00442A40 |. F7F9 idiv ecx00442A42 |. 8BC8 mov ecx,eax00442A44 |. 8B45 FC mov eax,[local.1]00442A47 |. BE 50000000 mov esi,0x5000442A4C |. 99 cdq00442A4D |. F7FE idiv esi00442A4F |. 03CA add ecx,edx00442A51 |. 41 inc ecx 算法伪代码为： 12345678910111213int i, j;DWORD sum = 0;for(i = 0; i &lt; strlen(Nome); i++)&#123; for(j = strlen(Nome) - 1; j &gt;= 0; j--) &#123; sum += Nome[i] * Nome[j] * key; &#125;&#125;sum = abs(sum) % 0xA2C2A;codice = codice / 0x59 + codice % 0x50 + 0x1 ‭最后比较两个结果。 12345678900442A52 |. 894D FC mov [local.1],ecx00442A55 |. 3B5D FC cmp ebx,[local.1]00442A58 |. 75 04 jnz short aLoNg3x_.00442A5E ; 跳转为验证失败，不跳转为验证成功00442A5A |. B3 01 mov bl,0x1 ; 设置成功标志为100442A5C |. EB 06 jmp short aLoNg3x_.00442A6400442A5E |&gt; 33DB xor ebx,ebx ; 设置成功标志为000442A60 |. EB 02 jmp short aLoNg3x_.00442A6400442A62 |&gt; 33DB xor ebx,ebx00442A64 |&gt; 33C0 xor eax,eax 4.AgainClick 该函数的过程与RegisterzClick函数的一样，所以就不再重复了。 具体的注册方法为： 输入注册名和用于生成key的注册码，点击Register按钮； 再次输入用于通过验证的注册码，再次点击Register按钮； Register按钮显示，again按钮显示； 再次重复第一步和第二步，换为点击again按钮。 可用的注册名和注册码需要进行计算，我使用的为，注册名：tested，生成key的注册码：tested，验证的注册码：28178495。 0x3 参考 初练160个CrakeMe程序之007 (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[160个CrackMe之009]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FCrackMe%2F160%E4%B8%AACrackMe%E4%B9%8B009%2F</url>
    <content type="text"><![CDATA[160个新手练习CrackMe，第9个。 0x1 环境 系统：Windows XP SP3 软件：Andrénalin.2.exe 工具：PEID v0.95、吾爱破解专用版OllyDbg 0x2 分析运行程序，注册名和注册码验证。 PEiD查壳，无壳，Microsoft Visual Basic 编写 输入任意注册名和注册码，会弹出注册失败提示。 载入OD，搜索字符串，确定失败提示，定位关键跳转。 12004022C8 . 66:85DB test bx,bx004022CB . 0F84 C0000000 je Andréna.00402391 ; 跳转为注册失败，不跳转为注册成功 向上分析发现验证函数。第一个参数为正确的注册码，第二个参数为输入的假码。 123450040229E . 50 push eax ; /var18 = 0012F4740040229F . 51 push ecx ; |var28 = 0012F4AC004022A0 . C745 A8 00000&gt;mov dword ptr ss:[ebp-0x58],0x0 ; |004022A7 . C745 94 08800&gt;mov dword ptr ss:[ebp-0x6C],0x8008 ; |004022AE . FF15 48414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarTs&gt;; \__vbaVarTstEq 每个参数地址向后第三个DWORD，就是保存的字符串地址。比如 var18 = 0x0012F474，那么 0x0012F47C 处的值就是字符串的起始地址。 向上分析，找到注册码计算算法。 首先采用循环将注册名的每一位相加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475004020D5 . B8 01000000 mov eax,0x1004020DA . 8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]004020E0 . 8985 5CFFFFFF mov dword ptr ss:[ebp-0xA4],eax004020E6 . 8985 4CFFFFFF mov dword ptr ss:[ebp-0xB4],eax004020EC . 8D55 BC lea edx,dword ptr ss:[ebp-0x44]004020EF . 51 push ecx ; /Step8 = 00120003004020F0 . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C] ; |004020F3 . BB 02000000 mov ebx,0x2 ; |004020F8 . 52 push edx ; |/var18 = 00000001004020F9 . 50 push eax ; ||retBuffer8 = NULL004020FA . 899D 54FFFFFF mov dword ptr ss:[ebp-0xAC],ebx ; ||00402100 . 899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx ; ||00402106 . FF15 18414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenVa&gt;; |\__vbaLenVar0040210C . 8D8D 44FFFFFF lea ecx,dword ptr ss:[ebp-0xBC] ; |00402112 . 50 push eax ; |End8 = NULL00402113 . 8D95 E8FEFFFF lea edx,dword ptr ss:[ebp-0x118] ; |00402119 . 51 push ecx ; |Start8 = 001200030040211A . 8D85 F8FEFFFF lea eax,dword ptr ss:[ebp-0x108] ; |00402120 . 52 push edx ; |TMPend8 = 0000000100402121 . 8D4D DC lea ecx,dword ptr ss:[ebp-0x24] ; |00402124 . 50 push eax ; |TMPstep8 = NULL00402125 . 51 push ecx ; |Counter8 = 0012000300402126 . FF15 20414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForInit0040212C . 8B3D 04414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFr&gt;; msvbvm50.__vbaFreeVarList00402132 &gt; 85C0 test eax,eax00402134 . 0F84 9C000000 je Andréna.004021D60040213A . 8D55 94 lea edx,dword ptr ss:[ebp-0x6C]0040213D . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]00402140 . 52 push edx00402141 . 50 push eax00402142 . C745 9C 01000&gt;mov dword ptr ss:[ebp-0x64],0x100402149 . 895D 94 mov dword ptr ss:[ebp-0x6C],ebx0040214C . FF15 90414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaI4Var&gt;; msvbvm50.__vbaI4Var00402152 . 8D4D BC lea ecx,dword ptr ss:[ebp-0x44] ; |00402155 . 50 push eax ; |Start = 0x000402156 . 8D55 84 lea edx,dword ptr ss:[ebp-0x7C] ; |00402159 . 51 push ecx ; |dString8 = 001200030040215A . 52 push edx ; |RetBUFFER = 000000010040215B . FF15 38414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcMidCha&gt;; \rtcMidCharVar00402161 . 8D45 84 lea eax,dword ptr ss:[ebp-0x7C]00402164 . 8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]00402167 . 50 push eax ; /String8 = NULL00402168 . 51 push ecx ; |ARG2 = 0012000300402169 . FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrVa&gt;; \__vbaStrVarVal0040216F . 50 push eax ; /String = NULL00402170 . FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \rtcAnsiValueBstr00402176 . 66:8985 4CFFF&gt;mov word ptr ss:[ebp-0xB4],ax0040217D . 8D55 CC lea edx,dword ptr ss:[ebp-0x34]00402180 . 8D85 44FFFFFF lea eax,dword ptr ss:[ebp-0xBC]00402186 . 52 push edx ; /var18 = 0000000100402187 . 8D8D 74FFFFFF lea ecx,dword ptr ss:[ebp-0x8C] ; |0040218D . 50 push eax ; |var28 = NULL0040218E . 51 push ecx ; |saveto8 = 001200030040218F . 899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx ; |00402195 . FF15 94414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarAd&gt;; \__vbaVarAdd0040219B . 8BD0 mov edx,eax0040219D . 8D4D CC lea ecx,dword ptr ss:[ebp-0x34]004021A0 . FFD6 call esi ; msvbvm50.__vbaVarMove004021A2 . 8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]004021A5 . FF15 B8414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStr004021AB . 8D55 84 lea edx,dword ptr ss:[ebp-0x7C]004021AE . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C]004021B1 . 52 push edx004021B2 . 50 push eax004021B3 . 53 push ebx004021B4 . FFD7 call edi ; msvbvm50.__vbaFreeVarList004021B6 . 83C4 0C add esp,0xC004021B9 . 8D8D E8FEFFFF lea ecx,dword ptr ss:[ebp-0x118]004021BF . 8D95 F8FEFFFF lea edx,dword ptr ss:[ebp-0x108]004021C5 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]004021C8 . 51 push ecx ; /TMPend8 = 00120003004021C9 . 52 push edx ; |TMPstep8 = 00000001004021CA . 50 push eax ; |Counter8 = NULL004021CB . FF15 AC414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \__vbaVarForNext004021D1 .^ E9 5CFFFFFF jmp Andréna.00402132 将相加的结果与 0x499602D2 相乘。 123456789004021D6 &gt; \8D4D CC lea ecx,dword ptr ss:[ebp-0x34]004021D9 . 8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]004021DF . 51 push ecx ; /var18 = 0012F4AC004021E0 . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C] ; |004021E3 . 52 push edx ; |var28 = 0012F474004021E4 . 50 push eax ; |SaveTo8 = 0012F474004021E5 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],0x499602D2 ; |004021EF . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x3 ; |004021F9 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarMu&gt;; \__vbaVarMul 使用 “-” 替换相乘结果十进制表示形式的第4位和第9位。 1234567891011121314151617181900402206 . 8B1D A0414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaMi&gt;; msvbvm50.__vbaMidStmtVar0040220C . 8D4D CC lea ecx,dword ptr ss:[ebp-0x34]0040220F . 51 push ecx00402210 . 6A 04 push 0x400402212 . 8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]00402218 . 6A 01 push 0x10040221A . 52 push edx0040221B . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; -00402225 . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x80040222F . FFD3 call ebx ; msvbvm50.__vbaMidStmtVar; &lt;&amp;MSVBVM50.__vbaMidStmtVar&gt;00402231 . 8D45 CC lea eax,dword ptr ss:[ebp-0x34]00402234 . 8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]0040223A . 50 push eax0040223B . 6A 09 push 0x90040223D . 6A 01 push 0x10040223F . 51 push ecx00402240 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; -0040224A . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x800402254 . FFD3 call ebx ; msvbvm50.__vbaMidStmtVar 例如，注册名为“test”，计算流程为： 注册名每一位相加，得到 0x1C0； 0x1C0 * 0x499602D2 = 0x‭80C684EF80‬ = ‭553086414720‬ 将 ‭553086414720‬ 中的第4位和第9位数字替换为 “-”； 得到注册码为 ‭553-8641-720。 进行验证。 0x3 参考 [反汇编练习] 160个CrackMe之009 (出处: 吾爱破解论坛)]]></content>
      <categories>
        <category>逆向分析</category>
        <category>CrackMe</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CE教程程序通关]]></title>
    <url>%2F2019%2F04%2F03%2FReverse%2FSoftware%2FCE%E6%95%99%E7%A8%8B%E7%A8%8B%E5%BA%8F%E9%80%9A%E5%85%B3%2F</url>
    <content type="text"><![CDATA[CheatEngine作为一款强大的内存修改工具，自带了一套使用教程，帮助新人可以快速上手使用。 教程一共分为9关，每一关都采用不同的搜索类型，帮助使用者熟悉CE的使用方法。 第一关第一关是欢迎关卡，说明如何使用CE加载目标进程。 打开CE； 点击“Open Process“按钮； 从进程列表中选择类似”00001F98-Tutorial-x86_64.exe“的Tutorial-x86_64进程； 发现目标进程后，点击”Open“按钮，即可附加到目标进程。 完成进程加载后，点击”Next“按钮进入下一关。 第二关第二关为精确值搜索。目标为将健康值修改为1000。 可以看到健康值，即Health值为100，点击一下”Hit me“，健康值减少随机数值。 首先”Scan Type“（扫描类型）选择”Exact Value“（精确值），”Value Type”（值类型）选择”4 Bytes”。 然后在Value框中输入100，点击”First Scan“（首次扫描），进行第一次扫描。 搜索结果出现了许多，无法确定哪个是目标地址。点击”Hit me“，健康值减少，输入新的健康值，点击”Next Scan“（再次扫描），进行第二次扫描。 重复上面步骤，直到结果惟一，即是目标地址。 双击加入地址列表。 双击地址最后一列的“Value”，将值修改为1000。“Next”按钮变为可点击，进入下一关。 第三关第三关为未知初始值。目标为将健康值修改为5000。 可以看到无法确定健康值的初始值，只有一个满格生命条。点击“Hit me”会显示减少的健康值，而且生命条也会减少。根据提示，可以知道健康值位于0-500之间。 点击“New Scan”，开启新的扫描； “Scan Type”选择“Unknown Initial value”（未知的初始化值）； “Value Type”选择“4 Butes”； 点击“First Scan”，进行第一次扫描。 点击“Hit me”，减少健康值； “Scan Type”选择“Decreased value”; 点击”Next Scan“，进行第二次扫描； 重复第二次扫描，直到结果数量不再变化； 选择符合健康值范围的地址，加入地址列表。 将值修改为5000。 点击”Next“，进入下一关。 第四关第四关为浮点指针。目标为将健康值和弹药修改为5000或更高。 首先修改健康值。 ”Scan Type“选择”Exact Value“； ”Value Type“选择”float“； Value输入框输入100，进行第一次搜索。 点击”Hit me“，减少健康值； 修改搜索数值，进行第二次搜索； 重复第二次搜索步骤，直到结果惟一； 结果加入地址列表，修改值为5000。 然后修改弹药值。 ”Scan Type“选择”Exact Type“； ”Value Type“选择”double“； 输入100，第一次搜索； 如果结果有多个，则点击”Fire“，减少弹药值，进行再次搜索； 当结果惟一时，加入地址列表，修改值为5000。 健康值和弹药值都搜索完毕后，进入下一关。 第五关第五关是代码查找。目的是查找修改值的汇编指令，并将其替换为nop指令。 首先确定目标值的地址。 确定后，加入地址列表，右击选择”找出什么写入该地址“，弹出空白指令窗口。 再次点击”Change value“按钮，空白指令窗口出现一条指令，该指令就是修改目标值的指令。 单击该指令，将其替换为nop指令。 点击”Stop“按钮，停止调试器，教程正常运行。 点击”Change value“后，目标值不会变化，进入下一关。 第六关第六关是指针。目标为找到目标值基址并冻结该值。 首先确定目标值的当前地址，加入地址列表。 右击该地址，找出什么访问了该地址。 双击任意一条指令，可以看到更多的信息。基地址为 0x00601630。 点击主界面上”Add Address Manually“，手动设置指针。 点击指针地址前的方框，锁定其值。点击教程中的”Change pointer“，改变指针。 进入下一关。 第七关第七关是代码注入。目标是通过代码注入是”Hit me“按钮增加2健康值。 首先定位健康值的地址，加入地址列表。 然后找出修改目标值的指令。 查看该指令处的反汇编窗口，打开”Auto assemble“（Ctrl + A）窗口。 生成代码注册模板。 12345678910111213141516171819alloc(newmem,2048)label(returnhere)label(originalcode)label(exit)newmem: //this is allocated memory, you have read,write,execute access//place your code hereoriginalcode:sub dword ptr [ebx+00000478],01exit:jmp returnhere&quot;Tutorial-i386.exe&quot;+2585D:jmp newmemnopnopreturnhere: 在//place your code here下输入想要执行的代码add dword ptr [ebx+00000478],03。 点击”Execute“，注入代码。 点击”Hit me“按钮，健康值增加2，进入下一关。 第八关第八关是多级指针。目标是找到4级指针的基址并将健康值锁定为5000。 首先找到健康值地址，加入地址列表。 找出访问该地址的指令，发现[esi + 18]，这是第一级指针esi = 0x01690370，偏移为 0x18。 主界面搜索第一级指针存储地址，加入地址列表。 找出访问该地址的指令，发现[esi]，第二级指针esi = 0x01723150，偏移为 0x0。 主界面搜索第二级指针存储地址，加入地址列表。 找出访问该地址的指令，发现[esi + 14]，第三级指针esi = 0x0166F060，偏移为 0x14。 主界面搜索第三级指针存储地址，加入地址列表。 找出访问该地址的指令，发现[esi + 0C]，第四纪指针esi = 0x01716000，偏移为 0xC。 主界面搜索第四级指针存储地址，加入地址列表。 找出访问该地址的指令，发现基址 0x00601660。 设置指针地址。 修改健康值为5000，锁定指针地址，点击教程界面”Change pointer“，进入下一关。 第九关第九关是共享代码。目的是处理其他相同类型对象共同使用的代码。 找到每个玩家健康值的地址，加入地址列表。 然后找出修改健康值的指令，共用指令mov [ebx + 0x4],eax。 查看四个玩家的ebx处的内存。 Player 1 12019647C8 78 E5 5A 00 00 00 C0 42 09 27 00 00 F3 E9 46 00 x錤...繠.&apos;..箝F.019647D8 01 00 00 00 04 44 61 76 65 00 00 00 00 00 00 00 ...Dave....... Player 2 120197CB68 78 E5 5A 00 00 00 BC 42 38 01 00 00 01 03 48 00 x錤...糂8..H.0197CB78 01 00 00 00 04 45 72 69 63 00 00 00 00 00 00 00 ...Eric....... Player 3 12019A47D0 78 E5 5A 00 00 00 F9 43 4C 25 00 00 F8 83 0E 00 x錤...鵆L%..鴥.019A47E0 02 00 00 00 03 48 41 4C 00 00 00 00 00 00 00 00 ...HAL........ Player 4 12019BCB70 78 E5 5A 00 00 00 F9 43 09 1A 00 00 90 B1 1C 00 x錤...鵆...惐.019BCB80 02 00 00 00 04 4B 49 54 54 00 00 00 00 00 00 00 ...KITT....... 分析可知，第5-8字节是玩家的健康值（小端序存储，以42000000为0，以健康值的2倍保存），第17个字节为队伍编号，第21字节为玩家名长度，第22字节开始是玩家名。 可以编写通过队伍编号进行区分的注入代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546alloc(newmem,2048)label(returnhere)label(originalcode)label(exit)newmem: //this is allocated memory, you have read,write,execute access//place your code herecmp byte ptr [ebx+10],0x01jne originalcodemov eax,[ebx+04]originalcode:mov [ebx+04],eaxfldz exit:jmp returnhere&quot;Tutorial-i386.exe&quot;+26857:jmp newmemreturnhere:alloc(newmem,2048)label(returnhere)label(originalcode)label(exit)newmem: //this is allocated memory, you have read,write,execute access//place your code herecmp byte ptr [ebx+07],0x42jne newmem2mov eax,[ebx+04]jmp originalcodenewmem2:mov eax,0x43000000originalcode:mov [ebx+04],eaxfldz exit:jmp returnhere&quot;Tutorial-i386.exe&quot;+26857:jmp newmemreturnhere: 注入代码后，点击”Restart game and autoplay“，完成关卡。]]></content>
      <categories>
        <category>逆向分析</category>
        <category>软件分析</category>
      </categories>
  </entry>
</search>
